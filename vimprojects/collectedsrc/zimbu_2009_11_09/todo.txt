SOON TO BE FIXED OR IMPLEMENTED:

GWT clone: convert Zimbu into javascript.  Serve on http server.
-> Include CSS in the generated HTML file.
	   ZWT.Button button = NEW("Hello")
	   ZWT.Style style = NEW("my-button")
	   style.setMargin(10)
	   button.setStyle(style)
-> avoid putting everything inside lib/zwtmodule.zu.  Can we do this:
	CLASS ZWT
	  ...
	  IMPORT "zwt/panel.zu"  # defines Panel as ZWT.Panel
	}
-> Remove all "use" flags from Dictlist module.
-> Implement dict in Javascript: use object {}, prepend ":" to key, turn int
   into string.
-> Caching for main zwt file 5 minutes?
    implement HTTP.Servlet.setCacheTime(seconds)

Bug: init() and PARENT.init() don't work in VerticalPanel.add().
   THIS.init() does work.

JS: module initializers can be written directly, no need for Imodule() init
function.

In a class method it's hard to see if a variable "foo" is an argument, local
var or a object member.  "this.foo" is too long.  Use $foo for object members?
Here "$" is short for "this.", thus elsewhere you can still use
"myobject.foo".  And it's still not allowed to use "foo" for argument or local
var to avoid making mistakes.
	CLASS Item
	  int val
	  PROC setVal(int _val)
	    $val = _val  # means: "this.val = _val"
	  }
	}

Implement |=.

Bug: testdir/inherit.zu gets stuck at 16 undefined symbols.

Disable use of GENERATE_IF outside of lib modules?

Implementation of PARENT.method() is a bit of a hack.

How to split up a ZWT tree into more than one JS file?

With SHARED inside CLASS Foo, use Foo.INFO().shared for the shared bits
Remove code to find class Date inside module Date.

Implement REPEAT like "WHILE TRUE".

Implement AND and OR, as alternatives to && and ||.  Find out what looks best.

Bug: Using Node.Type.new_def inside Node class gives error for emtpy module.
Should drop "Node." here.

This crashes:
	list<int> myList
	FOR i IN myList
	  ...
	}
When trying to iterate over a NIL value, just skip?

There is no check for arguments when calling Use.declWriters.add().

- Move more stuff from generate.zu to resolve.zu/write_c.zu/write_js.zu.
   Move class methods into the class for JS.
   	this.add() = function(y) {
	   this.x = y;
	};

Guido: having all composite mutable will cause problems for threading.  User
needs to use a lot of explicit locks.  Have everything in mutable and
immutable version?
	string
	const string = "asdf"
	list<int>
	const list<int> = [1, 2, 3]
	etc.
Also dynamic:
	list<int> mylist
	mylist.add(some)
	mylist.readonly()  # changes no longer possible, don't need locks

- Instead of using different outputs for declarations:
      - Add list to scope to produce variable declarations.
      - Add list at toplevel scope for structs, typedefs, etc.
      - When writing output, go through these lists.

Bug: defining asdf in testdir/something.zu getFive(): declaration isn't put
  at start of scope.  Happens in many places, something wrong with setting
  varOut?

Make list of vars work:
	bool a, b
Disallow inits before the comma:
	bool a, b = 1      # OK
	bool a = 1, b = 2  # ERROR

Todo later:
     Remove "outDir" from ZimbuFile?
     Change didInitFunc ?

- ZWT services: javascript sends requests to server.
  Use protocol buffers implemented in JSON.

Bug: ZwtDemoPage.init is not accepted as proc<>, while "init" is

- Module loader:
  Move more modules to work like HTTP?

- Have another look at Lua, esp. about closures.

- Look at Erlang for how it supports threads (ignore the syntax).

- Consider main goal: "A better C" ?
  Only for the non-threading and non-O-O parts.

- Have a look at Modula 3, sets are like BITS?

- Have a look at javafx: lazy evaluation, variable binding

- Look at this blog: http://gbracha.blogspot.com/

- Bug: cannot use Conversion.int2string.name()

- Trying to initialize an array results in code that creates a list.
  Either implement it or give a "not implemented" error.

- Threads: invoke run() indirectly, when it returns set a flag, so that we can
  use thread.running() to check.
  Use thread.running() in testserver.zu.

- "Output out = Output.NEW(NEW())"  doesn't work.

- Implement *=  /=  %=  ~=  |=  &=

- Make a difference between byte strings and character strings?
  + only one set of operations on both
  - Need two names, what to call them?  "string" and "bytestring"?
  - Can use byte and char funcions on one type.
  	s[N] = N'th character
	s.byte(N) = N'th byte
  + can use s[N] without wondering what happens.
  + Since they behave differently they should have different names.

- This doesn't work:
	  list<list<Symbol>> altList = NEW()
	  altList[0][0].toString("")

- Implement .TYPE().toString() to display type of THIS

- Implement object member init.
            CLASS Foo
	       string name = "none"
	    }

- Give an error when func ref return type doesn't match actual function return
  type.

- Also interesting: www.haxe.org.  Converts to javascript, flash, etc.

- Function defined inside function can't use vars defined in outer function.
  Pass pointer like with THIS?

- Design: Integer and float numbers in the code are specified without type.
  Only when assigning them to a certain type the compiler may complain when
  this results in an overflow.  E.g. assigning -1 to a Nat.
- Every method should have a "use" flag.  Skip generation when a method is not
  used.  Then use it for Dict?
  OR: do this by passes over the node tree, like GWT does.
- define flag: ARG.addFlag("n", "", FALSE, "do not add newline")
- Make a nice mechanism for invoking C functions, so that we can use all
  existing C libraries:
  -> with a nice Zimbu interface for some libraries
  -> directly, with Zimbu/C conversion for types, for the rest
  Later for C++? (dreaming of Qt...)
- R"literal\string"  double "" to get one
- '''literal''''''string'''  double ''' to get '''
- Define a var with the type of another var:
	TYPEOF(Stat.dev) dev
    or  Stat.dev.TYPE() dev
  Useful if you don't know the type of something but do want to keep a copy.

SMALLER ITEMS:
- Error for "class.attrbute.abstract" is about abstract instead of attrbute.
- Using "abc" + proc(), where proc() doesn't return a value, does not give an
  error.
- No error for using non-existent member: "scope.builtinsp[id]"
	Get error for subscript instead.
- Using somedict[key] doesn't work for string keys, somedict.get(key) works
  OK.
- Implement ISA and ISNOTA: use _isa table like _off and _ptr.
- Ignore case of user symbols after the first char.  "function", "fUNCTION",
  and "funCtiOn" are the same.
- class member vars are not initialized, e.g. for a List.
  use in testdir/inherit.zu for SomeList.idx
- For "unexpected EOF" error, print position of block start.
  Guess based on indent?
- Implement EMPTY() as SIZE() == 0 if EMPTY() is not defined.
- No error for CLASS with reserved name.  See testerrors.zu.


TO THINK ABOUT:
- Idea: handle locks like exceptions:
	use a block to obtain locks:
		LOCK(listLock.read, dictLock.write)
		  v = gothroughlist(list)
		  addtodict(dict, v)
		}
	A function specifies that it must be called with a lock held
	       FUNC gothroughlist(list list) LOCKED(listLock.read)
	         FOR l IN list
		   v = ...
		 }
		 RETURN v
	       }
	       PROC addtodict(dict dict, v v) LOCKED(dictLock.write)
	         dict[v.k] = v.v ...
	       }
	A variable specifies that it can only be accesed while holding a lock:
	lock listLock
	list<> list LOCKED(listLock)

- Garbage collection, nice way to handle cycles:
  http://www.research.ibm.com/people/d/dfb/papers/Bacon01Concurrent.pdf
- For real compilation, use LLVM?
- Documentation: Use common (generated) format and upload to code.google.com?
- Alternatives for implementing interface objects:
  1. More efficient inheritance when assuming that inherited member variables
     are exactly in the same order.
	Link to parent, check that nothing is defined twice, child struct
	contains all members from parent in same order, typecast for invoking
	method on parent.
	When using an interface, decide at runtime which function to call,
	depending on the actual type.
  2. Pass i_object to the function instead of THIS.  The function then needs
     to apply the _off and _ptr tables where THIS is used.

- By default a declaration creates a new object:
	  Node n  # automatically does n = Node()
   You get an error if there is no constructor without arguments.
   However, optimization may remove the init.
   To avoid init assign NULL:
	  Node n = NULL
   Alternatively, like Java:
   	  Node n          # defaults to NULL
	  Node n = NEW()  # creates an object

LATER:
- Executor, thread pools: create threads and recycle them.
- For short names:
  	USE IO.List, IO.File, IO.Stat, SYS.Timing
- Idea:
       FOR name[i] IN nameList
         IO.writeLine("name " + i ": " + name)
       }

Bugs to be fixed:
- IF s = "no" give error for white space, shouldbe that "=" -> "=="
- Get error for missing return too often.  Requires analyzing the branches in
  the node tree.
- Make a difference between class/enum Symbol and vars of that type.
- Using var name "new" or "int" conflicts with C reserved symbols.  Prepend
  something, e.g. "V".
- use bcopy() or memcpy() for systems that don't have memmove()
- Stat.size and Stat.time are int, should be int64.
- THIS.name doesn't work, if "name" is a member of the parent class.


Partly implemented:
- "For i IN var" only works for List of Int or String.
- List.toString() only works for Int and String.
- Optimization: if an interface has only one child it can be accessed
  directly, no need for a _ptr or _off table.
- Extend List type with:
        mylist += item
        newlist = mylist + item + item
        mylist.remove(item)        # removes first item where value equals
                                   # item, returns mylist
        n = mylist.index(item)     # lowest i where mylist[i] == item
        n = mylist.count(item)     # nr of times mylist[i] == item
        item = mylist.min()        # item with minimum value, uses COMPARE
        item = mylist.max()        # item with maximum value, uses COMPARE
        mylist.sort()              # returns mylist
        mylist.reverse()           # returns mylist
- Import should re-use already produced files.
  Write exported symbols in .ZUDIR/fname.zus

Future features:
- Implement =~ and !~ operators: regexp
- Add: Tuple type
- Implement config.zu: works like autoconf.  Store results in file (can be
  edited by user for porting and cross-compiling).

- Use protocol buffers for communication between processes, storing objects,
  etc.
  Use Google protobuf implementation.  Make it possible to subclass a protobuf
  to be able to add behavior.

- String should be implemented efficiently, depending on it's use.
  -> Most strings can be stored like C strings.  Use leading NUL byte to
     indicate this.  This overlaps strings in memory!
     These are immutable, no reference count.
  -> When string contains a NUL byte store as:
  	0x01     indicates string type: one length byte
	length   one byte length (up to 256)
	string   C-like string but with NUL bytes.
     Similarly: 0x02 16 bit length, 0x04 32 bit length, 0x08 64 bit length
  -> String in allocated memory
  	0x11     indicates allocated string type, one-byte length
	size     number of bytes allocated
	length   number of bytes used for string
	value[N]
     Similarly: 0x12 16 bit length, 0x14 32 bit length, 0x18 64 bit length
  -> String in allocated memory with offset and reference (like StringPiece)
  	0x21     indicates allocated string type, one-byte length
	offset   number of bytes skipped
	length   number of bytes used after offset
	pointer  points to string
     Similarly: 0x22 16 bit length, 0x24 32 bit length, 0x28 64 bit length
  -> When possibly making changes use a String refence:
        0x30	 indicates String reference
        pointer  points to string
  -> When making changes use Cord-like structure:
        0xff	 indicates Cord type
        size     number of pointers in array
        length   number of pointers in array used
        array	 pointer to array with pointers to strings
     The actual value is all the strings concatenated.

- set n_end in Node to specify where node ends in source file.

- Check use of "Zint" instead of "int" and other configured types.

- Create new object from class with class name: File("name")
  No need for a NEW operator.

- For Dict implement other keys than int and string.  Requires a func for
  class that gets its signature..

- Also support a List based on an array.  Much more efficient append and
  pop(), inefficient remove from the middle:
         NEW(ListType.array)
         NEW(ListType.array, 100)  # initial size
         NEW(ListType.linked)
  What to use as a default?  Use a small array, grow it when needed, turn into
  linked list when it becomes inefficient?
  Alt: let the user use an array, support automatic size.
  Alt: use a mixed implementation: list of arrays
	CLASS ListHead
	  ListArray first
	  ListArray last
	  Int       itemCount
	}
	CLASS ListArray
	  ListArray  next
	  ListArray  prev
	  Int        itemCount
	  ListItem   items[]
	}

- Add IO.readChar(), IO.File.readChar(), IO.writeChar(), IO.File.writeChar()
  for utf-8 characters.  Use in Input.get()

