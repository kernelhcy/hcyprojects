#
# Main file of the Zimbu compiler written in Zimbu.
#
# Usage:
#      zimbu {file}.zu    Compile {file}.zu
#
# Options:
#      -o {prog}       Store executable as {prog}
#      -x              Execute the compiled program
#      -d              Debug mode
#      -v              Verbose
#      -cc {compiler}  Use {compiler} for the C compiler
#
# And later:
#      zimbu                          Execute build commands in ZIMBU file
#      zimbu BUILD                    Execute build commands in BUILD file
#
# Copyright 2009 Bram Moolenaar
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# The License can be found it in the LICENSE file, or you may obtain a copy of
# the License at http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
# License for the specific language governing permissions and limitations
# under the License.
#

IMPORT "builtin.zu"
IMPORT "config.zu"
IMPORT "error.zu"
IMPORT "generate.zu"
IMPORT "node.zu"
IMPORT "output.zu"
IMPORT "parse.zu"
IMPORT "scope.zu"
IMPORT "usedfile.zu"
IMPORT "write_c.zu"

MAIN()
  string inFileName
  string progName
  bool   execute
  string executeArgs = ""
  IF ARG.SIZE() == 0
    IO.write("Usage: " .. ARG.name
             .. " [-x] [-d] [-v] [-cc compiler] [-o progname] source.zu ...\n")
    EXIT 1
  }

  # TODO: ARG module should parse flags
  int idx = 0
  WHILE TRUE
    IF ARG.args[idx] == "-x"
      # "-x": execute
      execute = TRUE
      idx++
      CONTINUE
    }
    IF ARG.args[idx] == "-d"
      # "-d": debug
      Error.debug = TRUE
      idx++
      CONTINUE
    }
    IF ARG.args[idx] == "-v"
      # "-v": verbose, can be repeated
      Error.verbose++
      idx++
      CONTINUE
    }
    IF ARG.args[idx] == "-o" && ARG.SIZE() - idx > 2
      # "-o output".
      progName = ARG.args[idx + 1]
      idx += 2
      CONTINUE
    }
    IF ARG.args[idx] == "-cc" && ARG.SIZE() - idx > 2
      # "-cc compiler".
      Config.compiler = ARG.args[idx + 1]
      idx += 2
      CONTINUE
    }
    BREAK
  }

  IF ARG.SIZE() - idx < 1
    IO.write("Missing source file argument\n")
    EXIT 1
  }
  inFileName = ARG.args[idx]
  idx++

  IF idx < ARG.SIZE()
    IF !execute
      IO.write("SORRY, only one .zu file is currently allowed\n")
      EXIT 1
    }
    DO
      executeArgs ..= " " .. ARG.args[idx]
      idx++
    UNTIL idx == ARG.SIZE()
  }

  # Catch common mistakes in arguments.
  IF inFileName.byteSlice(-3, -1) != ".zu"
    IO.writeLine("ERROR: Input name must end in '.zu': " .. inFileName)
    EXIT 1
  }

  # Run auto-configuration.  Fills in values for the Config module.
  IF Config.run() != OK
    IO.write("ERROR: Config failed, cannot compile a program\n")
    EXIT 1
  }

  string rootName = inFileName.byteSlice(0, -4)  # without ".zu"
  IF progName == NIL
    progName = rootName .. Config.exeSuffix
  }

  # Prepare for defining builtin modules when used.
  Builtin.prepare()

  # Try opening the output file now.  It's pointless to start parsing if we
  # can't write the result.
  string outFileName = rootName .. ".c"
  IO.File outFile = IO.fileWriter(outFileName)
  IF outFile == NIL
    IO.writeLine("ERROR: Cannot open file for writing: " .. outFileName)
    EXIT 1
  }

  #
  # Parse |inFileName|.
  #
  UsedFile mainFile = NEW(inFileName, isMainFile + isTopFile)
  IF mainFile.parse("") == FAIL
    IO.writeLine("ERROR: Cannot open file for reading: " .. inFileName)
    EXIT 1
  }

  #
  # Resolve symbols.
  # Repeat this until they are all defined or no more can be resolved.
  #
  bool doPass = TRUE
  WHILE doPass && !Error.foundError
    doPass = Generate.resolve(mainFile)
  }

  #
  # Produce C code from the parse tree and write it to outFile.
  #
  IF !Error.foundError
    Output.Heads heads = NEW()
    Output.Group outputs = NEW(heads)
    Generate.write(mainFile, outputs)  # Write the C code into |heads|.

    # Write the collected C code into the output file.
    outFile.write("/*\n")
    outFile.write(" * Generated from Zimbu file " .. inFileName .. "\n")
    outFile.write(" */\n")
    Write_C.writeFile(heads, mainFile.scope(), outFile)
  }

  outFile.close()

  # If there are no errors, compile the produced C code into a program.
  int retval = 1
  IF !Error.foundError
    # Not all C compilers return a non-zero value for failure.
    # Delete the binary and check that it was updated and has some size.
    IO.delete(progName)
    IO.Stat before = IO.stat(progName)
    string cmd = Config.compilerCmd(outFileName, progName)
    IF Error.verbose > 0
      IO.writeLine("Executing compiler: " .. cmd)
    }

    retval = SYS.shell(cmd)
    IO.Stat after = IO.stat(progName)
    IF after.size == 0
      IO.write("ERROR: Compiled program is zero size\n")
      retval = 1
    ELSEIF before.size == after.size && before.time == after.time
      IO.write("ERROR: Compiled program was not updated\n")
      retval = 1
    }
  }

  # Execute the program if "-x" was given
  IF retval == 0 && execute
    IF progName[0] != '/'
      progName = "./" .. progName
    }
    retval = SYS.shell(progName .. executeArgs)
  }

  RETURN retval
}
