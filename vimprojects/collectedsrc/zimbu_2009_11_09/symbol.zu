#
# The Zimbu compiler written in Zimbu
#
# Symbol class.
#
# Copyright 2009 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT "attr.zu"
IMPORT "generate.zu"
IMPORT "node.zu"
IMPORT "output.zu"
IMPORT "pos.zu"
IMPORT "resolve.zu"
IMPORT "scontext.zu"
IMPORT "scope.zu"

CLASS Symbol
  string    name
  string    cName         # name to use in generated C
  Node.Type type
  int       value         # value for enum, identNumber for function,
                          # bit offset for BITS
  int       mask          # bitmask for the value (1 for bool, 3, 7, etc.
                          # for enum
  bool      used          # this symbol was used somewhere

  list<Symbol>  memberList # used when type is something with members, e.g.
                          # Node.Type.module, Node.Type.enum,
                          # Node.Type.class

  Scope     scope         # Scope that contains this symbol.
  list<Symbol>  children  # used for a class that has children or classes
                          # implementing the interface of this class.
                          # And an interface: classes that implement it.

  Symbol    class         # Symbol of class when |type| is Node.Type.class
                          # or Node.Type.enum
  string    className     # class this symbol is a member of, name of the
                          # class or NIL
  bool      noGenerate    # no code was generated when symbol was defined

  Symbol    parentClass   # class that is being extended by this class
  list<Symbol> interfaces # interfaces that are implemented by this class

  Output    structOut     # defines class struct members
  Symbol    keySymbol     # key type for Dict
  Symbol    returnSymbol  # used when type is Node.Type.function
                          # item type for a list
  Attr      attributes    # flags: FINAL, ABSTRACT, etc.
  Node      node          # Node that defines this symbol (can be NIL)
  Pos       pos           # where it was defined

  Resolve.TargetLang  tlang  # hack: language that code was generated for
  dict<string, string> zwtPermu  #hack: ZWT permutations

  proc<Symbol, Symbol, Node, SContext>  produce
                          # method to produce output

  # construct a Symbol that only has the type set.
  NEW(Node.Type _type)
    type = _type
  }

  # For debugging.
  FUNC string toString()
    RETURN toString("", TRUE)
  }

  FUNC string toString(string indent, bool recurse)
    string res = indent .. "Symbol"
    IF name != NIL
      res ..= " name: " .. name
    }
    res ..= " type: " .. type.name() .. "\n"
    IF class != NIL
      res ..= indent .. "  class: " .. class.name .. "\n"
    }
    IF parentClass != NIL
      res ..= indent .. "  parent: " .. parentClass.name .. "\n"
    }
    IF recurse && returnSymbol != NIL
      res ..= indent .. "  returnSymbol: "
                             .. returnSymbol.toString(indent .. "    ", FALSE)
    }
    IF recurse && memberList != NIL
      res ..= indent .. "  members:\n"
      FOR m IN memberList
        IF m == NIL
          res ..= indent .. "    NIL\n"
        ELSE
          res ..= m.toString(indent .. "    ", FALSE)
        }
      }
    }
    IF recurse
      IF children != NIL
        res ..= indent .. "  children:\n"
        FOR m IN children
          IF m == NIL
            res ..= indent .. "    NIL\n"
          ELSE
            res ..= m.toString(indent .. "    ", FALSE)
          }
        }
      ELSE
        res ..= indent .. "  no children\n"
      }
    }
    RETURN res
  }

  FUNC string dumpSymbols()
    string s = type.name() .. " { "
    s ..= "name : " .. name
    s ..= " }"
    RETURN s
  }

  PROC addFromSymbol(string dump)
    int idx
    int len = dump.SIZE()
    WHILE idx < len
      string head = dump.slice(idx, idx + 20)
      int w = head.index(' ')
      IF w < 0
        BREAK
      }
      string symType = head.slice(0, w)
      BREAK
    }
  }

  # Shallow copy of a Symbol.  Note that list of members is equal in the
  # copy!
  FUNC Symbol copy()
    Symbol ret = NEW(type)
    ret.name = name
    ret.cName = cName
    ret.value = value
    ret.mask = mask
    ret.used = used
    ret.memberList = memberList
    ret.children = children
    ret.class = class
    ret.className = className
    ret.parentClass = parentClass
    ret.interfaces = interfaces
    # don't copy structOut
    ret.keySymbol = keySymbol
    ret.returnSymbol = returnSymbol
    ret.attributes = attributes
    # don't copy node
    IF pos != NIL
      ret.pos = pos.copy()
    }
    ret.produce = produce
    RETURN ret
  }

  # Like copy(), but when the symbol is a class return an object of that
  # class.
  FUNC Symbol copyObject()
    Symbol ret = copy()
    IF type == Node.Type.class
      ret.type = Node.Type.object
      ret.class = THIS
    }
    RETURN ret
  }

  # Add a member |_name| with Node.Type and class as specified by |typeSym|
  # and value |_value|.
  # Return the Symbol for the new member
  FUNC Symbol addMember(string _name, Symbol typeSym, int _value)
    Symbol s
    IF typeSym == NIL
      s = NEW(Node.Type.unknown)
    ELSE
      s = typeSym.copy()
    }
    s.name = _name
    s.value = _value

    # Append s to |memberList|.
    RETURN addMember(s)
  }

  # Add a member.
  FUNC Symbol addMember(Symbol typeSym)
    IF memberList == NIL
      memberList = NEW()
    }
    memberList.add(typeSym)
    RETURN typeSym
  }

  # Remove a member.
  PROC removeMember(Symbol sym)
    IF memberList != NIL
      int i
      WHILE i < memberList.SIZE()
        IF memberList[i] IS sym
          memberList.pop(i)
          RETURN
        }
        ++i
      }
    }
  }

  FUNC bool hasMember()
    RETURN memberList != NIL && memberList.SIZE() > 0
  }

  PROC addChild(Symbol child)
    IF children == NIL
      children = NEW()
    ELSE
      # Only add it when it isn't there yet
      FOR s IN children
        IF s IS child
          RETURN
        }
      }
    }
    children.add(child)
  }

  PROC addInterface(Symbol itf, Node _node)
    IF interfaces == NIL
      interfaces = NEW()
    ELSE
      # Only add it when it isn't there yet
      FOR s IN interfaces
        IF s IS itf
          _node.error("Duplicate interface")
          RETURN
        }
      }
    }
    interfaces.add(itf)
  }

  # Find |child| in children, return its index.
  # This works recursively.
  # Return -(number of children) - 1 when not found.
  FUNC int findChild(Symbol child)
    int idx
    IF children != NIL
      FOR s IN children
        IF s IS child
          RETURN idx
        }
        IF !s.attributes.abstract
          idx++
        }
        IF s.children != NIL
          int ci = s.findChild(child)
          IF ci >= 0
            RETURN idx + ci
          }
          idx += -(ci + 1)
        }
      }
    }
    RETURN -(idx + 1)
  }

  # Return the index of |child| in the list of children, used as the index
  # in the "_off" member and "_ptr" method tables.
  FUNC int childIndex(Symbol child)
    IF child == NIL
      RETURN 0
    }
    IF child IS THIS
      # Index of the parent itself is zero.
      RETURN 0
    }
    int i = findChild(child)
    IF i >= 0
      # Index of a child is list index, plus one for non-abstract class.
      RETURN i + (attributes.abstract ? 0 : 1)
    }
    RETURN -1
  }

  # Add a member that is a library function, use |produceProc| to produce
  # the C code.
  FUNC Symbol addLibMethod(string _name,
                      proc<Symbol, Symbol, Node, SContext> produceProc,
                           Symbol _returnSymbol)
    Symbol member = addMember(_name, NEW(Node.Type.lib_method), 0)
    member.produce = produceProc
    member.returnSymbol = _returnSymbol
    RETURN member
  }

  FUNC list<Symbol> getMemberList()
    IF type == Node.Type.ref && returnSymbol != NIL
      RETURN returnSymbol.getMemberList()
    }
    IF (type == Node.Type.class || type == Node.Type.object) && class != NIL
      # The members of a class may be changed after the symbol was defined,
      # e.g., for a "next" member.
      RETURN class.memberList
    }
    RETURN memberList
  }

  FUNC Symbol findMember(string _name)
    Symbol s = find(getMemberList(), _name)
    IF s == NIL && (type == Node.Type.object || type == Node.Type.class)
                                                         && parentClass != NIL
      RETURN parentClass.findMember(_name)
    }
    RETURN s
  }

  # Find member with name and arguments equal to |member|.
  FUNC Symbol findMatchingMember(Symbol member)
    IF memberList == NIL
      RETURN NIL
    }
    FOR m IN memberList
      IF m.name == member.name
        IF m.memberList == NIL && member.memberList == NIL
          RETURN m
        }
        int idx
        IF member.memberList != NIL
          WHILE idx < m.memberList.SIZE()
            IF !Generate.compatibleSymbols(member.memberList[idx],
                                                            m.memberList[idx])
              BREAK
            }
            idx++
          }
        }
        IF idx == m.memberList.SIZE()
          RETURN m
        }
      }
    }
    RETURN NIL
  }

  FUNC Symbol findMember(string _name, Node.Type typeReq)
    Symbol s = find(getMemberList(), _name, typeReq)
    IF s == NIL && (type == Node.Type.object || type == Node.Type.class)
                                                         && parentClass != NIL
      RETURN parentClass.findMember(_name, typeReq)
    }
    RETURN s
  }

  FUNC string getClassName()
    IF class != NIL && class.className != NIL
      RETURN class.className
    }
    RETURN className
  }

  FUNC bool matches(string _name, Node.Type _type)
    RETURN name == _name && (_type == Node.Type.unknown || type == _type)
  }

  # Find the first method with name |method| that matches the arguments
  # |argList|.  Skip symbol |skip|.
  # The caller should probably check if there is another function
  # that matches.
  FUNC Symbol findMatchingFunction(string method,
                                   list<Symbol> argList,
                                   Symbol skip,
                                   bool searchParent,
                                   bool convert)
    bool foundSkip
    Symbol match = findMatchingFunctionInList(memberList, method, argList,
                                                    skip, &foundSkip, convert)
    IF match == NIL && (type == Node.Type.object || type == Node.Type.class)
                         && searchParent && !foundSkip && parentClass != NIL
      RETURN parentClass.findMatchingFunction(method, argList, skip,
                                                                TRUE, convert)
    }
    RETURN match
  }

  FUNC Node.Type getReturnType()
    IF returnSymbol == NIL
      RETURN Node.Type.unknown
    }
    RETURN returnSymbol.type
  }

  FUNC bool isPointerType()
    RETURN Node.isPointerType(type)
  }

  FUNC bool isMethodType()
    RETURN Node.isMethodType(type)
  }

  SHARED

    # A few fixed symbols that can be passed around efficiently
    Symbol unknown = NEW(Node.Type.unknown)
    Symbol bool = NEW(Node.Type.bool)
    Symbol status = NEW(Node.Type.status)
    Symbol int = NEW(Node.Type.int)
    Symbol string = NEW(Node.Type.string)
    Symbol parent = NEW(Node.Type.parent)
    Symbol array = NEW(Node.Type.array)
    Symbol nil = NEW(Node.Type.nil)
    Symbol proc_ref = NEW(Node.Type.proc_ref)
    Symbol func_ref = NEW(Node.Type.func_ref)

    # Find Symbol with name |name| in the symbol list |list|.
    FUNC Symbol find(list<Symbol> list, string name)
      IF list != NIL
        FOR sym IN list
          IF sym.name == name
            sym.used = TRUE
            RETURN sym
          }
        }
      }
      RETURN NIL
    }

    # Find Symbol with name |name| and type |type| in the symbol list |list|.
    # When |type| is Node.Type.unknown it matches any type.
    FUNC Symbol find(list<Symbol> list, string name, Node.Type type)
      IF list != NIL
        FOR sym IN list
          IF sym.matches(name, type)
            sym.used = TRUE
            RETURN sym
          }
        }
      }
      RETURN NIL
    }

    # Find the first method with name |method| in memberList that matches the
    # arguments |argList|.  Skip symbol |skip|.
    # When |convert| is TRUE accept automatic conversion to string.
    # The caller should check if there is another function that matches, using
    # |skip|.
    FUNC Symbol findMatchingFunctionInList(list<Symbol> memberList,
                                           string method,
                                           list<Symbol> argList,
                                           Symbol skip,
                                           bool &foundSkip,
                                           bool convert)
      IF memberList == NIL
        RETURN NIL
      }
      int argListSize
      IF argList != NIL
        argListSize = argList.SIZE()
      }
      FOR sym IN memberList
        IF sym IS skip
          foundSkip = TRUE
        ELSEIF sym.name == method
          int size
          IF sym.memberList != NIL
            size = sym.memberList.SIZE()
          }
          IF size == argListSize
            int idx
            WHILE idx < size
              Symbol a1 = sym.memberList[idx]
              Symbol a2 = argList[idx]
              IF a2 == NIL
                BREAK
              }
              # We can convert a reference to what it refers to and the other
              # way around.
              IF a1.type == Node.Type.ref && a1.returnSymbol != NIL
                a1 = a1.returnSymbol
              }
              IF a2.type == Node.Type.ref && a2.returnSymbol != NIL
                a2 = a2.returnSymbol
              }
              IF !(a1.type == a2.type
                          && ((a1.type != Node.Type.object
                                                && a1.type != Node.Type.class)
                              || a1.class IS a2.class)
                      || (a1.type == Node.Type.class
                           && a2.type == Node.Type.object
                           && a1.class IS a2.class)
                      || a1.type == Node.Type.any
                      || a2.type == Node.Type.unknown
                             # Int fits any BITS type, because we can't detect
                             # the type from the expression (flag1 + flag2).
                      || ((a1.type == Node.Type.bits_small
                              || a1.type == Node.Type.bits_big)
                                               && a2.type == Node.Type.int)
                      || (a1.type == Node.Type.func_ref
                                             && a2.type == Node.Type.func_def)
                      || (a1.type == Node.Type.func_def
                                             && a2.type == Node.Type.func_ref)
                      || (a1.type == Node.Type.proc_ref
                                             && a2.type == Node.Type.proc_def)
                      || (a1.type == Node.Type.proc_def
                                             && a2.type == Node.Type.proc_ref)
                      || (convert && Generate.compatibleSymbols(a2, a1))
                      )
                BREAK
              }
              idx++
            }
            IF idx == size
              sym.used = TRUE
              RETURN sym  # found a match
            }
          }
        }
      }
      RETURN NIL
    }

  }

}
