# A Zimbu program for quickly testing the compiler.

IMPORT "testdir/something.zu"    # defines module Something
IMPORT "testdir/nothing.zu"      # empty file
IMPORT "testdir/subdir/some.zu"  # test subdirectory
IMPORT "testdir/errors.zu"       # check compiler errors
IMPORT "testdir/inherit.zu"      # classes, inheritance, interfaces
IMPORT "testdir/threadtest.zu"   # threads and locks
IMPORT "testdir/httptest.zu"     # HTTP server
IMPORT "testdir/date.zu"         # Date class

MODULE TestBits
  BITS MyFlags
    bool  one
    bool  two
    Kolor color
    bool  three
    bool  four
    int5  count
    nat2  unsigned
  }
  ENUM Kolor
    red
    green
    blue
  }
  MyFlags flags = three
  PROC bitTester()
    bitter(two + four + color=green + count=-16 + unsigned=3)
    MyFlags tflags = one + two + three + color=blue + count=5 + unsigned=1
    bool flag
    bitter(two + (flag ? three : 0))
    bitter(tflags)
    bitter(0)
    IF tflags.two
      IO.writeLine(R"bit two")
    }
    IF flags.three
      IO.writeLine(R"bit ""three""")
    }
    IO.writeLine("count is " .. tflags.count
                 .. "; unsigned is " .. tflags.unsigned)
    tflags = 0
    flags.one = FALSE
    flags.two = TRUE
    flags.three = (2 > 4)
    flags.four = (4 > 2)
    flags.color = Kolor.green
    flags.count = -6
    flags.unsigned = 3
    IO.writeLine("flags.one: " .. flags.one
             .. ", flags.two: " .. flags.two
             .. ", flags.three: " .. flags.three
             .. ", flags.four: " .. flags.four)
    IO.writeLine("flags.color: " .. flags.color.name()
             .. " and also: " .. flags.color)
    Kolor otherColor = flags.color
    GENERATE_IF lang == "C"
      IO.writeLine("color is still " .. otherColor.name())
    GENERATE_ELSE
      IO.writeLine("something wrong " .. otherColor.name())
    }
    IO.writeLine("count is " .. flags.count
                 .. "; unsigned is " .. flags.unsigned)
  }
  PROC bitter(MyFlags foo)
    IF foo.one
      IO.writeLine("bit one")
    }
  }
}

MODULE TestDict
  dict<string, string> somedict = NEW()
  dict<string, int> stringdict = {"one": 1, "two": 2}
  dict<int, string> intdict = {1: "one", 2: "two"}
  PROC try()
    IO.writeLine(somedict.toString())
    somedict["one"] = "xxx"
    # somedict.add("one", "xxx")  # should throw exception
    somedict["one"] = "111"
    IO.writeLine(somedict.toString())
    # somedict.remove("xxx")  should throw exception
    somedict.remove("one")
    IO.writeLine(somedict.toString())

    IO.writeLine(stringdict.toString())
    IO.writeLine(intdict.toString())
    IO.writeLine("one is " .. stringdict["one"])
    IO.writeLine("two is " .. stringdict["two"])
    IO.writeLine("1 is " .. intdict[1])
    IO.writeLine("2 is " .. intdict[2])
    VAR copydict = stringdict.COPY()
    IO.writeLine("copy: " .. copydict.toString())
    stringdict.clear()
    IO.writeLine("empty: " .. stringdict.toString())
  }
}

MODULE TestList
  CLASS SomeVal
    string name

    NEW(string n)
      name = n
    }
  }

  CLASS ListItem
    string name
    int    value
    NEW(string _name, int _value)
      name = _name
      value = _value
    }
  }

  ListItem five = NEW("five", 5)
  ListItem six = NEW("six", 5)

  PROC testje()
    list<string> noList = []
    list<string> strList = NEW()
    strList.add("hello").add("there")
    IO.writeLine(strList[0] .. " " .. strList[1] .. " and "
           .. strList[-2] .. " " .. strList[-1])

    list<int> intList = NEW()
    intList.add(333).add(444)
    intList.insert(999, 9)
    intList.insert(888, -1)
    intList.insert(222)
    intList.insert(111, -9)
    IO.writeLine(intList[0] .. " " .. intList[1] .. " " .. intList[2] .. " "
               .. intList[-3] .. " " .. intList[-2] .. " " .. intList[-1])
    WHILE intList.SIZE() > 0
      IO.write(" pop " .. intList.pop())
    }
    IO.write("\n")

    list<SomeVal> someList
    someList = NEW()
    someList.add(NEW("jop"))
    someList.add(NEW("jip")).add(NEW("jap"))
    IO.write(someList.SIZE() .. " items: ")
    VAR copyList = someList.COPY()
    IO.writeLine(copyList[0].name .. copyList[1].name .. copyList[-1].name)
    copyList.clear()
    IO.writeLine("After clear: " .. copyList.SIZE())

    VAR xstringList = list<string>.NEW().add("1").add("2").add("3").add("4")
    IO.writeLine("slice: " .. xstringList.slice(2, -1).toString())

    list<string> stringList = NEW().add("1").add("2").add("3").add("4")
    VAR partList = stringList.pop(2, -1)
    IO.write("stringList: " .. stringList.toString())
    IO.writeLine("  partList: " .. partList.toString())

    partList.extend(stringList)
    IO.writeLine("partList + stringList: " .. partList.toString())

    # test FOR on list of string
    list<string> abc = ["a", "b", "c", 4, ]
    IO.writeLine(abc
                    .toString()
                    )
    FOR s IN abc
      IO.write(s .. " ")
    }
    IO.write("\n")

    # test FOR on list of int
    list<int> abx = [4, 3, 2, 1
        ]
    int i
    IO.writeLine(abx.toString())
    FOR i IN abx
      IO.write(i .. " ")
    }
    IO.write("\n")

    # test FOR on list of objects
    list<ListItem> items = [NEW("one", 1), NEW("two", 2)]
    FOR item IN items
      IO.writeLine("ListItem " .. item.name .. "=" .. item.value)
    }
    IO.writeLine("Found: " .. findItem(items, "two").value)

    findItem([five, six], "six")
  }

  FUNC ListItem findItem(list<ListItem> items, string name)
    FOR item IN items
      IF item.name == name
        RETURN item
      }
    }
    RETURN NIL
  }
}

MODULE Great
  string value = "Great value"
  FUNC int getThree()
    RETURN 3
  }
  MODULE Sub
    int int = 5    # this is allowed but not nice
    int dict = 5
    int list = 5
    int proc = 5
    int xyz = 4
    FUNC string getFive()
      RETURN "five"
    }
  }
  ENUM Nested
    one two three
  }

}

PROC tryout(Great.Nested bar)
  Great.Nested foo = Great.Nested.one
  foo = bar
}

FUNC int addTen(int n, int m)
  getNone()
  int nn = n
  ++nn
  RETURN nn + m + 9
}

PROC getNone()
  VAR v
  v = "called getNone\n"
  IO.write(v.SIZE() .. ": ")
  IO.write(v)
  IF TRUE
    RETURN
  }
  IO.write("error")
}

string xyz

ENUM TType
  value
  eof
  string
  char
  int
}

CLASS Koken
  TType   type
  string  value
  Koken   next

  PROC setType(TType _type)
    type = _type
    IO.writeLine(type.name())
  }
  PROC setValue(string _value)
    value = _value
  }
  FUNC TType getType()
    RETURN type
  }
  FUNC string getValue()
    RETURN value
  }
}

PROC testToken()
  Koken t = NEW()
  t.setType(TType.eof)
  t.setValue("token")
  IO.writeLine("Koken type: " .. t.type.name() .. ", value: " .. t.getValue())
  Koken x = t.next

  Koken nt = NEW()
  nt.setValue("Next")
  t.next = nt
  IO.writeLine("next method: " .. t.next.getValue() .. ", member: " .. t.next.value)

  Koken nnt = NEW()
  nnt.setValue("NextNext")
  nt.next = nnt
  IO.write("next-next member: " .. t.next.next.value)
  IO.writeLine(", method: " .. t.next.next.getValue())
}

CLASS Input
  IO.File     _fd              # input stream
  int         _lnum
  int[100]    _prevc           # characters pushed back
  int         _prevcIdx        # current index in _prevc[]
  Koken[100]  _someToken       # previously read and pushed back token
  int         _prevToken_idx   # current index in prev_token[]

  NEW()
    _lnum = -1
  }
  NEW(string x)
    _lnum = -1
  }
  NEW(int lnum)
    _lnum = lnum
  }
  NEW(string x, int lnum)
    _lnum = lnum
  }

  PROC read()
    _lnum = -1
  }
  PROC read(string x)
    _lnum = -1
  }
  PROC read(int lnum)
    _lnum = lnum
  }
  PROC read(string x, bool flag)
    _lnum = 23
  }

  PROC testRead()
    read("hoho")
    Koken token = NEW()
    read(token.getValue())
    IO.Stat st = IO.stat("file")
    IO.writeLine("size: " .. st.size .. ", time: " .. st.time)
  }

  FUNC Input getIt()
    RETURN THIS
  }
}

PROC testInput()
  Input one = NEW()
  Input two = NEW("he")
  Input three = NEW(22)
  Input four = NEW("ho", 22)
  one.read()
  two.read("hi")
  three.read(23)
  four.read("hu", TRUE)
}

FUNC int get(Input input)
  int c

  IF input._prevcIdx > 0
    c = input._prevc[--input._prevcIdx]
  ELSE
    DO
      c = input._fd.readByte()
      IF c == IO.eof
        c = 0
      }
      IF c == '\t'
        IO.writeLine("WARNING: found Tab character in line " .. input._lnum)
        c = ' '
      }
    UNTIL c != '\r'  # CR characters are always ignored
    IF c == '\n'
      ++input._lnum
      IO.write("Hello\n")
    }
  }
  RETURN c
}

FUNC int getLnum(Input input)
  RETURN input._lnum
}

PROC print(string text)
  IO.writeLine("text: " .. text)
}
PROC print(int nr)
  IO.writeLine("number: " .. nr)
}
PROC print(bool what)
  IO.writeLine("Bool: " .. what)
}
PROC print(status what)
  IO.writeLine("Status: " .. what)
}
PROC print(list<string> names)
  IO.writeLine("list: " .. names.toString())
}
PROC print(list<string> names, bool yes)
  IO.writeLine("list: " .. names.toString() .. yes)
}

FUNC status doIt(bool fail)
  RETURN fail ? FAIL : OK
}

FUNC bool invert(bool flag)
  RETURN !flag
}

MAIN()
  SYS.shell("echo SYS says hello")
  string testje = SYS.malloc(300)
  testje = SYS.realloc(testje, 400)

  IO.write("testing IO")
  IO.writeByte('\n')
  IO.flush()
  IO.delete("/dev/null")  # fails
  IO.Stat st = IO.stat("file")

  Some.print()

  FUNC string addNSMP(int n, string s, int m, string p)
    RETURN n .. s .. m .. p
  }

  # Test getting arguments, also out of range.
  int ai = -1
  WHILE ai <= ARG.SIZE()
    IO.writeLine("Arg " .. ai .. " == " .. ARG.get(ai))
    IF ai >= 0 && ai < ARG.SIZE() && ARG.get(ai) != ARG.args[ai]
      IO.write("ERROR: ARG.get(i) != ARG.args[i]\n")
    }
    ++ai
  }
  # Test the functions that get the list of arguments
  list<string> lAll = ARG.getAll()
  VAR lClean = ARG.getClean()

  IO.writeLine("not true is " .. invert(TRUE)
           .. " and not false is " .. invert(FALSE))

  print(OK)
  print(FAIL)
  IO.writeLine("fail is " .. doIt(TRUE) .. " and !fail is " .. doIt(FALSE))

  int sum = 0
  sum += 123
  sum += 444
  string concat = " one"
  concat ..= " two"
  concat ..= " three"
  IO.writeLine(sum .. concat)

  IO.writeLine(Great.value .. "-" .. Great.getThree() .. "-"
               .. Great.Sub.xyz .. "-" .. Great.Sub.getFive())

  Something.Foobar foobar = NEW(123)
  IO.writeLine(foobar.get() .. Something.name .. Something.getFive())

  # Create an object of a nameless class inside a module
  Something not = NEW("another nothing")
  IO.writeLine("Something object: " .. not.text .. " and " .. Something.nope())
  not.text = "xyz"
  Something xno = not.get()
  xno.text = "nnn"
  not.get().text = "abc"

  testToken()

  Input inp = NEW(55)
  IO.write("Input lnum = " .. getLnum(NEW(88)))
  IO.writeLine(" and " .. Input.NEW(76)._lnum)

  int nx
  DO
    ++nx
  UNTIL nx == 3
  IO.write("nx: " .. ++nx)
  IO.write(" == " .. nx--)
  IO.write(" and " .. nx++)
  IO.writeLine(" == " .. --nx)

  IO.writeLine(addNSMP(42, " is ", 12, " plus 30"))
  xyz = "Global\n"
  IO.write(xyz)

  CLASS Type
    int  type
    bool flag
  }

  CLASS Node
    string name
    int type
    int[100]    prevc
    Type[11]   types

    NEW()
      name = "not set"
    }

    EQUAL(Node n)
      RETURN name == n.name && type == n.type
    }
  }

  int xx = addTen(22, 11)
  IO.writeLine("got " .. addTen(8, 14))

  ENUM Color
    blue
    red
    black
  }

  PROC nodeInc(Node node)
    ++node.type
  }

  int asdf
  Node node = NEW()
  node.type = 2
  ++asdf
  node.name = "class" .. " Node "
  nodeInc(node)
  IO.writeLine(node.name .. node.type)

  VAR nnode
  nnode = Node.NEW(); nnode = Node.NEW()
  IO.writeLine("Node name is " .. nnode.name)

  VAR e = Color.blue
  SWITCH e
    CASE Color.red
      # PROCEED  # gives an error
      IO.write("red\n")
    CASE Color.blue
      IO.write("blue\n")
      PROCEED
    CASE Color.black
      IO.write("black\n")
      PROCEED  # ignored
  }

  e = Color.red
  SWITCH e
    CASE Color.red; IO.write("red\n")
      PROCEED
    CASE Color.blue
       IO.write("blue\n"); BREAK

CASE Color.black
   IO.write("not black\n")
   IO.write("black\n")
   BREAK
  }

  int i = e == Color.blue ? 99 : "yes" == "bar" ? 55 : 48
  IO.writeLine("i = " .. i.toChar())

  # test directory creation
  IO.mkdir("/tmp/testdir")

  # test writing a file
  IO.File wfd = IO.fileWriter("/tmp/ttest")
  wfd.write("hello ")
  i = 49
  WHILE i <= 57
    wfd.writeByte(i)
    i = i + 1
  }
  wfd.writeByte(10)
  wfd.close()

  bool yes = TRUE
  IF !yes
    IO.write("this is wrong\n")
  ELSE
    IO.write("this is right\n")
  }
  Type no = NEW()
  no.flag = FALSE
  IO.writeLine("yes is " .. yes .. " and no is " .. no.flag)

  IO.File iofd = IO.fileReader("/tmp/ttest")
  int ioc = iofd.readByte()
  iofd.close()
  IO.File iowfd = IO.fileWriter("/tmp/tttest")
  iowfd.writeByte(1234)
  iowfd.write("hello" .. "there")
  iowfd.close()

  # test reading a file
  IO.File fd = IO.fileReader("/tmp/ttest")
  i = 6
  string s = ""
  WHILE i > 0
    int c = fd.readByte()
    s = s .. c.toChar()
    i = i - 1
  }
  IO.write(s)
  i = 10
  WHILE i > 0
    int c = fd.readByte()
    IO.write(c .. " ")
    i = i - 1
  }
  fd.close()
  IO.write("\n")

  string x = "hello" .. " world!\n"
  IO.write(x)
  GENERATE_IF lang == "JS"
>>> # this code is ignored
  nothing matters here
<<<
  GENERATE_ELSE
>>> # this is C code
  printf("C code\n");
<<<
  }
  # IO.write("Char 5 is " .. x[5] .. "\n")
  int n = 42
  IF n == 42
    IO.writeLine("yes, it is " .. n)
  ELSEIF n < 42
    IO.writeLine("no, it is smaller")
  ELSE
    IO.writeLine("no, it is " .. n)
  }
  IO.writeLine(5 + 7 * 8)
  IO.writeLine("Int.SIZE() = " .. 88.SIZE() .. 64.toChar())

  string soo = "Hello"
  IF soo == "Hello"
    IO.write("== Hello ")
  }
  IF soo IS "Hello" .. ""
    IO.write("IS Hello ")
  }

  Node noden = NEW()
  Node othern = noden
  Node nodem = NEW()
  IF noden == othern
    IO.write("== othern ")
  }
  IF noden IS othern
    IO.write("IS othern ")
  }
  IF noden == nodem
    IO.write("== nodem ")
  }
  IF noden IS nodem
    IO.write("IS nodem ")
  }
  IO.write("\n")

  TestList.testje()
  TestDict.try()
  TestBits.bitTester()

  IO.writeLine("5 >> 1 = " .. (5 >> 1))
  IO.writeLine("8 >> 2 = " .. (8 >> 2))
  IO.writeLine("8 << 1 = " .. (8 << 1))
  IO.writeLine("1 << 4 = " .. (1 << 4))

  PROC echoInt(int nn, string xtra)
    IO.write("echoInt(" .. nn .. ", " .. xtra .. ")\n")
  }

  PROC doNothing()
    IO.writeLine("doNothing()")
  }

  FUNC string getInt(int nn, string xtra)
    RETURN "getInt(" .. nn .. ", " .. xtra .. ")\n"
  }

  FUNC int genInt()
    RETURN 8
  }

  # Test reference to function
  proc<int, string> echoIntRef
  echoIntRef = echoInt
  echoIntRef(5, "-")

  proc<> dono = doNothing
  dono()

  func<int> noGetInt
  noGetInt = genInt
  IO.writeLine("func ref: " .. noGetInt())

  func<string, int, string> newGetInt
  newGetInt = getInt
  IO.write(newGetInt(9, "blah"))

  # test slice()
  string blah = "Nat32"
  int bits = blah.byteSlice(3, -1).toInt()
  IO.writeLine("slice(3, -1): " .. blah.byteSlice(3, -1) .. " = " .. bits)
  blah = "12345"
  IO.writeLine("slice(0, 0): " .. blah.byteSlice(0, 0))
  IO.writeLine("slice(0, 1): " .. blah.byteSlice(0, 1))
  IO.writeLine("slice(0, 4): " .. blah.byteSlice(0, 4))
  IO.writeLine("slice(0, 5): " .. blah.byteSlice(0, 5))
  IO.writeLine("slice(0, 99): " .. blah.byteSlice(0, 99))
  IO.writeLine("slice(1, 99): " .. blah.byteSlice(1, 99))
  IO.writeLine("slice(4, 99): " .. blah.byteSlice(4, 99))
  IO.writeLine("slice(5, 99): " .. blah.byteSlice(5, 99))
  IO.writeLine("slice(6, 99): " .. blah.byteSlice(6, 99))
  IO.writeLine("slice(3, -1): " .. blah.byteSlice(3, -1))
  IO.writeLine("slice(3, -2): " .. blah.byteSlice(3, -2))
  IO.writeLine("slice(3, -3): " .. blah.byteSlice(3, -3))
  IO.writeLine("slice(3, -5): " .. blah.byteSlice(3, -5))
  IO.writeLine("slice(3, -6): " .. blah.byteSlice(3, -6))
  IO.writeLine("slice(-2, -1): " .. blah.byteSlice(-2, -1))
  IO.writeLine("slice(-1, -1): " .. blah.byteSlice(-1, -1))
  IO.writeLine("slice(-4, -4): " .. blah.byteSlice(-4, -4))
  IO.writeLine("slice(-5, -5): " .. blah.byteSlice(-5, -5))
  IO.writeLine("slice(-6, -6): " .. blah.byteSlice(-6, -6))

  noden = NIL
  IO.writeLine("here found: " .. (noden == NIL))

  # Pass int by reference
  PROC incrAndMult(int &nr)
    nr++
    nr = nr * 2
  }
  int testNr = 2
  incrAndMult(&testNr)
  IO.writeLine("incremented 2 to " .. testNr)

  # Pass object by reference
  PROC changeObject(Node &nod, bool recurse)
    nod = NEW()
    nod.name = "by reference"
    string some = nod.name
    IF recurse
      changeObject(nod, FALSE)
    }
  }
  Node nodeX = NEW()
  Node bef = nodeX
  changeObject(&nodeX, TRUE)
  IO.writeLine("node name is " .. nodeX.name .. ", "
               .. (bef IS nodeX ? "same" : "different") .. " object")
  Node nop
  changeObject(&nop, TRUE)

  IO.writeLine("1234: " .. 1'234 .. ", 1000000: " .. 1'000'000)
  IO.writeLine("0b01010101: " .. 0b0101'0101
             .. ", 0B1001010101: " .. 0B10'0101'0101)
  IO.writeLine("0X1A2B3C: " .. 0X1A'2B'3C .. ", 0x1a2b3c: " .. 0x1a'2b'3c)

  string empty = ""
  IO.writeLine("toLower of AbCdEf: " .. ("AbCdEf".toLower())
                .. "; toLower of empty string: '" .. empty.toLower() .. "'")

  string fuubar = "fuubar"
  IO.writeLine("index of fuu in fuubar: " .. fuubar.find("fuu"))
  IO.writeLine("index of bar in fuubar: " .. fuubar.find("bar"))
  IO.writeLine("index of foo in fuubar: " .. fuubar.find("foo"))

  string bar = "bar"
  IO.writeLine("fuubar starts with fuu: " .. fuubar.startsWith("fuu"))
  IO.writeLine("fuubar starts with bar: " .. fuubar.startsWith("bar"))
  IO.writeLine("bar starts with fuubar: " .. bar.startsWith(fuubar))
  IO.writeLine("empty starts with empty: " .. empty.startsWith(empty))

  IO.writeLine("fuubar ends with fuu: " .. fuubar.endsWith("fuu"))
  IO.writeLine("fuubar ends with bar: " .. fuubar.endsWith("bar"))
  IO.writeLine("bar ends with fuubar: " .. bar.endsWith(fuubar))
  IO.writeLine("empty ends with empty: " .. empty.endsWith(empty))

  string v = -(234)

  # check that resizing a dictionary works properly
  dict<string, int> tokenLookup = {
      "ANY": 33,
      "ARG": 33,
      "BITS": 33,
      "BREAK": 33,
      "CASE": 33,
      "CLASS": 33,
      "CONTINUE": 33,
      "COPY": 33,
      "DEFAULT": 33,
      "DEFINE": 33,
      "DO": 33,
      "ELSE": 33,
      "ELSEIF": 33,
      "ENUM": 33,
      "EQUAL": 33,
      "EXIT": 33,
      "EXTENDS": 33,
      "FAIL": 33,
      "FALSE": 33,
      "FINAL": 33,
      "FOR": 33,
      "FUNC": 33,
      "IF": 33,
      "IMPLEMENTS": 33,
      "IMPORT": 33,
      "IN": 33,
      "INTERFACE": 33,
      "IO": 33,
      "IS": 33,
      "ISA": 33,
      "ISNOT": 33,
      "ISNOTA": 33,
  }
  list<string> tokenNames = [
      "ANY", "ARG", "BITS", "BREAK", "CASE", "CLASS", "CONTINUE", "COPY",
      "DEFAULT", "DEFINE", "DO", "ELSE", "ELSEIF", "ENUM", "EQUAL", "EXIT",
      "EXTENDS", "FAIL", "FALSE", "FINAL", "FOR", "FUNC", "IF", "IMPLEMENTS",
      "IMPORT", "IN", "INTERFACE", "IO", "IS", "ISA", "ISNOT", "ISNOTA",
  ]
  FOR t IN tokenNames
    IF tokenLookup[t] != 33
      IO.writeLine("Value of " .. t .. " is " .. tokenLookup[t] .. " instead of 33")
    }
  }

  # Test inheritance.
  Inherit.test()

  # Test threads.
  ThreadTest.test()

  Date date = Date.fromString("Jun 1 1001")
  Date.asdf = 234
}
