#
# The Zimbu compiler written in Zimbu
#
# Write_JS class and module: Methods are invoked from Generate for each node
# to generate JavaScript code.
#
# Copyright 2009 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT "conversion.zu"
IMPORT "dictstuff.zu"
IMPORT "error.zu"
IMPORT "generate.zu"
IMPORT "liststuff.zu"
IMPORT "node.zu"
IMPORT "output.zu"
IMPORT "resolve.zu"
IMPORT "scontext.zu"
IMPORT "scope.zu"
IMPORT "symbol.zu"
IMPORT "zimbufile.zu"

# The methods that are implemented for the Resolve.I interface are commented
# in resolve.zu.
CLASS Write_JS IMPLEMENTS Resolve.I

  Resolve.TargetLang targetLang
  string permuName

  NEW()
    targetLang = Resolve.TargetLang.js
  }

  FUNC string getLangName()
    RETURN "JS"
  }

  FUNC string thisName(bool insideNew)
    IF insideNew
      # We create a new object with this name.
      RETURN newThisName
    }
    # Use the Javascript mechanism to access the current object.
    RETURN "this"
  }

  FUNC ZimbuFile.CodeSpecific getCS(ZimbuFile zimbuFile)
    RETURN zimbuFile.js
  }

  PROC mainHead(SContext ctx)
    Error.report("Can't use MAIN() in ZWT file")
  }

  PROC mainEnd(Node node, SContext ctx)
    # error already reported by mainHead()
  }

  # >>> C block
  PROC copyC(Node node, SContext ctx)
  }

  # >>> JS block
  PROC copyJS(Node node, SContext ctx)
    ctx.out.write(node.n_string)
  }

  # Allocate a new object.
  PROC writeAlloc(string typeName, SContext ctx)
    ctx.out.write("new " .. typeName .. "()")
  }

  PROC writeListAlloc(SContext ctx)
    ctx.out.write("[]")
  }

  PROC writeNewThis(Symbol sym, SContext ctx)
    ctx.out.writeIndent(1)
    ctx.out.write("var " .. newThisName .. " = ")
    writeAlloc(sym.className, ctx)
    ctx.out.write(";\n")
  }

  PROC writeNewReturn(Output out)
    out.writeIndent(1)
    out.write("return " .. newThisName .. ";\n")
  }

  # Write the name of this symbol, surrounding it with what is required to
  # access it.
  PROC writeSymName(Symbol sym, SContext ctx)
    IF sym.type == Node.Type.ref
      ctx.out.write("(*")
      IF sym.returnSymbol != NIL
        ctx.out.write(sym.returnSymbol.cName)
      }
      ctx.out.write(")")
    ELSEIF sym.className != NIL
      ctx.out.write(ctx.scope.thisName .. "." .. sym.cName)
    ELSE
      ctx.out.write(sym.cName)
    }
  }

  FUNC Symbol id(Node node, SContext ctx, Symbol destSym)
    Symbol sym = node.n_symbol
    IF sym == NIL
      IF ctx.out.writing
        node.error("unknown symbol: " .. node.n_string)
      }
    ELSE
      writeSymName(sym, ctx)
    }
    RETURN node.n_returnSymbol
  }

  FUNC Symbol methodReturnType(Node node, Symbol sym, SContext ctx)
    Symbol retSym
    IF node.n_type == Node.Type.new_def
      retSym = ctx.scope.class
    ELSEIF node.n_type == Node.Type.equal_def
      retSym = NEW(Node.Type.bool)
    ELSEIF node.n_type == Node.Type.func_def
      retSym = Generate.generateDeclType(node.n_returnType, ctx.copyNoOut())
    }

    # There is no return type.
    ctx.out.write("function ")
    ctx.out.write(sym.cName .. "(")

    RETURN retSym
  }

  PROC writeMethodCall(Symbol func, bool moreArgs, SContext ctx)
    IF func.className != NIL
      ctx.out.write(ctx.scope.thisName .. "." .. func.name .. "(")
    ELSE
      ctx.out.write(func.cName .. "(")
    }
  }

  PROC argWithType(bool first, Symbol typeSym, Node typeNode,
                                               string argName, SContext ctx)
    IF !first
      ctx.out.write(", ")
    }
    # There is no type.
    ctx.out.write(argName)
  }

  # Return TRUE when forward declarations are to be written.
  FUNC bool doWriteDecl()
    RETURN FALSE
  }

  FUNC Symbol subscript(Node node, SContext ctx, Symbol destSym)
    # Get type of "expr".
    # TODO: this is a hack, it should be possible to use node.n_symbol
    Symbol sym = Generate.genExpr(node.n_left, ctx.copyNoOut(), NIL)

    Symbol ret
    IF sym != NIL
      IF sym.type == Node.Type.list
        ret = ListStuff.generateSubscript(sym, node, FALSE, ctx, destSym)
      ELSEIF sym.type == Node.Type.dict
        ret = DictStuff.generateSubscript(sym, node, FALSE, ctx, destSym)
      ELSEIF sym.type == Node.Type.array
        Generate.genExpr(node.n_left, ctx, Symbol.array)
        ctx.out.write("[")
        Generate.genExpr(node.n_right, ctx, Symbol.int)
        ctx.out.write("]")
        IF sym.returnSymbol != NIL
          ret = sym.returnSymbol.copy()
        ELSEIF ctx.out.writing
          node.error("type of array item unknown")
        }
      ELSEIF sym.type == Node.Type.string
        Generate.genExpr(node.n_left, ctx, Symbol.string)
        ctx.out.write("[")
        Generate.genExpr(node.n_right, ctx, Symbol.int)
        ctx.out.write("]")
        ret = Symbol.int
      ELSEIF ctx.out.writing
        node.error("type does not allow subscript: " .. sym.type.name())
      }
    ELSEIF ctx.out.writing
      # Generate the error message for "expr"
      Generate.genExpr(node.n_left, ctx, NIL)
    }
    RETURN ret
  }

  # Generate accessing an object member |objSym| of an interface |itfSym|.
  PROC iobjectMember(Symbol objSym, Symbol itfSym, Node node,
                                                 SContext ctx, Symbol destSym)
    # some.member
    Generate.genExpr(node.n_left, ctx, destSym)
    ctx.out.write("." .. objSym.cName)
    node.n_undefined = node.n_left.n_undefined
  }

  # Binary operator with int values.
  PROC numberOp(Node node, SContext ctx)
    ctx.out.write("(")
    Generate.genExpr(node.n_left, ctx, Symbol.int)
    string op
    SWITCH node.n_type
      CASE Node.Type.bit_and;   op = " & "
      CASE Node.Type.bit_or;    op = " | "
      CASE Node.Type.bit_xor;   op = " ^ "
      CASE Node.Type.op_rshift; op = " >> "
      CASE Node.Type.op_lshift; op = " << "
      CASE Node.Type.op_mult;   op = " * "
      CASE Node.Type.op_div;    op = " / "
      CASE Node.Type.op_rem;    op = " % "
      CASE Node.Type.op_plus;   op = " + "
      CASE Node.Type.op_minus;  op = " - "
      DEFAULT
              node.error("INTERNAL: numberOp not implemented")
    }
    ctx.out.write(op)
    Generate.genExpr(node.n_right, ctx, Symbol.int)
    ctx.out.write(")")
  }

  # String concatenation operator.
  PROC concatOp(Node node, SContext ctx)
    Generate.genExpr(node.n_left, ctx, Symbol.string)
    ctx.out.write(" + ")
    Generate.genExpr(node.n_right, ctx, Symbol.string)
  }

  FUNC Node.Type plusOp(Node node, SContext ctx, Node.Type destType)
    numberOp(node, ctx)
    RETURN Node.Type.int
  }

  PROC incrdecrOp(Node node, SContext ctx)
    IF node.n_type == Node.Type.op_pre_incr
      ctx.out.write("++")
    ELSEIF node.n_type == Node.Type.op_pre_decr
      ctx.out.write("--")
    }
    ctx.out.write("(")
    Generate.genExpr(node.n_left, ctx, Symbol.int)
    ctx.out.write(")")
    IF node.n_type == Node.Type.op_post_incr
      ctx.out.write("++")
    ELSEIF node.n_type == Node.Type.op_post_decr
      ctx.out.write("--")
    }
  }

  PROC booleanOp(Node node, SContext ctx)
    ctx.out.write("(")
    IF node.n_nodeType == Node.Type.nil
      Generate.genExpr(node.n_left, ctx, Symbol.nil)
      IF node.n_type == Node.Type.op_notequal
                                      || node.n_type == Node.Type.op_isnot
        ctx.out.write(" != ")
      ELSE
        ctx.out.write(" == ")
      }
      Generate.genExpr(node.n_right, ctx, Symbol.nil)
    ELSEIF node.n_nodeType == Node.Type.string
      Generate.genExpr(node.n_left, ctx, Symbol.string)
      IF node.n_type == Node.Type.op_equal
        ctx.out.write(" == ")
      ELSE
        ctx.out.write(" != ")
      }
      Generate.genExpr(node.n_right, ctx, Symbol.string)
    ELSEIF node.n_nodeType == Node.Type.object
      IF node.n_symbol.type == Node.Type.object
        # Create a node for "left.EQUAL(right)"
        Node m = NEW(Node.Type.method)
        m.n_left = NEW(Node.Type.member)
        m.n_left.n_string = "EQUAL"
        m.n_left.n_left = node.n_left
        m.n_left.n_start = node.n_start
        m.n_right = node.n_right
        Generate.generateCall(m, ctx, Symbol.bool, TRUE)
      ELSE
        Generate.genExpr(node.n_left, ctx, node.n_symbol)
        IF node.n_type == Node.Type.op_equal
          ctx.out.write(" == ")
        ELSE
          ctx.out.write(" != ")
        }
        Generate.genExpr(node.n_right, ctx, node.n_symbol)
      }
    ELSE
      bool err = Generate.genExpr(node.n_left, ctx, NIL) == NIL
      err = err || Generate.genExpr(node.n_right, ctx, NIL) == NIL
      IF !err
        node.error("INTERNAL: booleanOp()")
      }
    }
    ctx.out.write(")")
  }

  PROC compareOp(Node node, SContext ctx)
    ctx.out.write("(")
    Generate.genExpr(node.n_left, ctx, Symbol.int)
    SWITCH node.n_type
      CASE Node.Type.op_lt;  ctx.out.write(" < ")
      CASE Node.Type.op_lte; ctx.out.write(" <= ")
      CASE Node.Type.op_gt;  ctx.out.write(" > ")
      CASE Node.Type.op_gte; ctx.out.write(" >= ")
    }
    Generate.genExpr(node.n_right, ctx, Symbol.int)
    ctx.out.write(")")
  }

  PROC andorOp(Node node, SContext ctx)
    ctx.out.write("(")
    Generate.genExpr(node.n_left, ctx, Symbol.bool)
    IF node.n_type == Node.Type.op_and
      ctx.out.write(" && ")
    ELSE
      ctx.out.write(" || ")
    }
    Generate.genExpr(node.n_right, ctx, Symbol.bool)
    ctx.out.write(")")
  }

  FUNC Symbol parens(Node node, SContext ctx, Symbol destSym)
    ctx.out.write("(")
    Symbol ret = Generate.genExpr(node.n_left, ctx, destSym)
    ctx.out.write(")")
    RETURN ret
  }

  FUNC Symbol altOp(Node node, SContext ctx, Symbol destSym)
    ctx.out.write("(")
    Generate.genExpr(node.n_cond, ctx, Symbol.bool)
    ctx.out.write(") ? (")
    Generate.genExpr(node.n_left, ctx, destSym)
    ctx.out.write(") : (")
    Symbol symr = Generate.genExpr(node.n_right, ctx, destSym)
    ctx.out.write(")")
    # TODO: if destSym is NIL check syml and symr are the same type
    IF symr != NIL
      RETURN symr.copy()
    }
    RETURN NIL
  }

  FUNC Symbol listPart(Node node, SContext ctx, Symbol destSym)
    RETURN ListStuff.generateListPart_JS(node, ctx, destSym)
  }

  PROC dictPart(Node node, Symbol ret, SContext ctx)
    DictStuff.generateDictPart_C(node, ret, ctx)
  }

  FUNC Symbol expr(Node node, SContext ctx, Symbol destSym)
    Symbol retConverted
    string close = ""

    # A node may be visited more than once, check that the destination type
    # is specified.
    IF destSym != NIL && destSym.type != Node.Type.unknown
      SWITCH node.n_conversion
        CASE Conversion.int2string
          ctx.out.write("\"\" +")
          retConverted = NEW(Node.Type.string)
        CASE Conversion.bool2string
          ctx.scope.addUsedItem("bool2string")
          ctx.out.write("Zbool2string(")
          close = ")"
          retConverted = NEW(Node.Type.string)
        CASE Conversion.status2string
          ctx.scope.addUsedItem("status2string")
          ctx.out.write("Zstatus2string(")
          close = ")"
          retConverted = NEW(Node.Type.string)
        CASE Conversion.object2iobject
          # Javascript takes care of this
          retConverted = destSym
      }
    }

    Symbol ret = Generate.genExprChecked(node, ctx, destSym)

    ctx.out.write(close)
    IF retConverted != NIL
      RETURN retConverted
    }
    RETURN ret
  }

  # Write the file for IMPORT.ZWT.  It is JavaScript inside a HTML file.
  # Imported files are included in the current output.
  FUNC string writeImport(ZimbuFile import, Output.Group myOuts, Scope scope)
    # Use the module name for file name.
    string moduleName = import.getModuleName()
    IO.mkdir(import.outDir)
    string fname = import.outDir .. "/" .. moduleName
                                                .. "." .. permuName .. ".html"
    IO.writeLine("Writing file " .. fname .. "...")

    IO.File fd = IO.fileWriter(fname)
    IF fd == NIL
      IO.writeLine("ERROR: Cannot open file for writing: " .. fname)
      EXIT 1
    }

    fd.write('''<html>
  <head>
    <script>
      var $wnd = parent;
      var $doc = $wnd.document;
    </script>
  </head>
  <body>
    <script><!--
''')

    IF !myOuts.typeOut.head1.empty()
      fd.write("// typedefs\n")
      myOuts.typeOut.head1.write(fd)
    }

    fd.write("\n// structs\n")
    myOuts.structOut.head1.write(fd)

    fd.write("\n// declarations\n")
    writeDecl(import.topScope, fd)
    myOuts.declOut.head1.write(fd)

    fd.write("\n// bodies\n")
    writeBodies(import.topScope, fd)
    myOuts.bodyOut.head1.write(fd)

    # The init() function is always invoked.
    # TODO: should this also invoke inits of imported modules?
    fd.write("\nM" .. moduleName .. "__Finit();\n")

    fd.write("    --></script>\n  </body>\n</html>\n")

    fd.close()
    IO.writeLine("Done.")

    RETURN fname
  }

  # Write lines to "myOuts" to include the generated code for imported
  # files.
  # TODO: if the imported file is a .zwt file load the script file generated
  # for it.
  PROC writeIncludeImport(ZimbuFile import, Output.Group myOuts, Scope scope)
    # Include the imported files in the current file.
    string pre = "// including " .. import.rootName

    IF !myOuts.typeOut.head1.empty()
      myOuts.typeOut.write(pre .. " typedefs\n")
      myOuts.typeOut.head1.append(import.js.heads.typedefs)
    }

    myOuts.structOut.write(pre .. " structs\n")
    myOuts.structOut.head1.append(import.js.heads.structs)

    myOuts.declOut.write(pre .. " declarations\n")
    myOuts.declOut.head1.append(import.js.heads.declares)

    myOuts.bodyOut.write(pre .. " bodies\n")
    myOuts.bodyOut.head1.append(import.js.heads.funcBodies)
  }

  FUNC bool needWrite(ZimbuFile zimbuFile)
    IF zimbuFile.js.startedWrite != NIL
                                     && zimbuFile.js.startedWrite == permuName
      RETURN FALSE
    }
    zimbuFile.js.startedWrite = permuName
    zimbuFile.js.clear()
    RETURN TRUE
  }

  # Write class type declaration.
  PROC writeClassDef(string name, Output typeOut)
    # no forward declarations are needed.
  }

  # Write class declaration. |structOut| has the body.
  PROC writeClassDecl(Symbol classSym, Output.Group outs, Output structOut)
    string name = classSym.cName
    outs.structOut.write("function " .. name .. "() {\n")
    outs.structOut.write("}\n")

    outs.structOut.write("_ = " .. name .. ".prototype = ")
    IF classSym.parentClass != NIL
      outs.structOut.write("new " .. classSym.parentClass.cName .. "();\n")
    ELSE
      outs.structOut.write("{};\n")
    }

    IF classSym.memberList != NIL
      FOR s IN classSym.memberList
        IF Node.isMethodType(s.type)
          IF s.name != "NEW"
            outs.structOut.write("_." .. s.name .. " = ")
            outs.structOut.write(s.cName)
            outs.structOut.write(";\n")
            IF s.attributes.replace
              # Also write the parent method, so that we can call
              # PARENT.method().
              Symbol parent = classSym.parentClass
              WHILE parent != NIL
                Symbol otherSym = parent.findMatchingFunction(
                                      s.name, s.memberList, NIL, FALSE, FALSE)
                IF otherSym != NIL
                  outs.structOut.write("_.parent__" .. s.name .. " = ")
                  outs.structOut.write(otherSym.cName)
                  outs.structOut.write(";\n")
                  BREAK
                }
                parent = parent.parentClass
              }
            }
          }
        ELSE
          outs.structOut.write("_." .. s.cName .. " = ")
          defaultInit(s, outs.structOut)
          outs.structOut.write(";\n")
        }
      }
    }
  }

  # Write the default init value for |sym|.
  PROC defaultInit(Symbol sym, Output out)
    IF Node.isPointerType(sym.type)
      out.write("null")
    ELSE
      out.write("0")
    }
  }

  PROC nil(SContext ctx)
    ctx.out.write("null")
  }

  PROC member(string name, Output out)
    out.write("." .. name)
  }

  PROC vardecl(SContext ctx, Output out)
    IF ctx.scope.isClassScope() && !ctx.scope.statements
      out.write(ctx.scope.thisName .. ".")
    ELSE
      out.write("var ")
    }
  }

  # JavaScript doesn't use types.
  PROC vartype(Symbol sym, Node node, Scope scope, Output out)
  }

  PROC forStart(Output out)
    out.write("var Zf = ZforNew(")
  }

  PROC forLoop(Symbol varSym, Output out)
    out.write("for (")
    out.write(varSym.cName .. " = ZforGet(Zf, " .. varSym.cName .. "); ")
    out.write("ZforCont(Zf); ")
    out.write(varSym.cName .. " = ZforNext(Zf, &" .. varSym.cName .. ")")
    out.write(") {\n")
  }

  SHARED
    string newThisName = "thisO"  # Name of "THIS" inside NEW()
                                  #
    # Write struct and function declarations to |fd|.
    PROC writeDecl(Scope topScope, IO.File fd)
      IF topScope.usedItems.has("for")
        fd.write("// for used\n")
      }
    }

    # Write function bodies to |fd|.
    PROC writeBodies(Scope topScope, IO.File fd)
      IF topScope.usedItems.has("list") || DictStuff.useDict
        fd.write('''
function Zerror(msg) {
  alert("ERROR: " + msg);
}
''')
      }

      # List type
      ListStuff.writeBody_JS(topScope, fd)
    }
  }
}
