#
# The Zimbu compiler written in Zimbu
#
# SYS module
#
# Copyright 2009 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT "../generate.zu"
IMPORT "../node.zu"
IMPORT "../output.zu"
IMPORT "../scontext.zu"
IMPORT "../scope.zu"
IMPORT "../symbol.zu"
IMPORT "../write_c.zu"

MODULE LibSYS
  bool useZsleep

  # Return the symbol for the module.  The members of this symbol contain all
  # the items that the module defines.
  FUNC Symbol getSymbol()
    Symbol sym = NEW(Node.Type.lib_module)
    sym.name = "SYS"
    sym.cName = "MSYS"
    Write_C.bodyWriters.add(writeBody)

    Symbol member
    member = sym.addLibMethod("shell", shell, Symbol.int)
    member.addMember("command", Symbol.string, 0)

    member = sym.addLibMethod("sleep", sleep, NIL)
    member.addMember("usec", Symbol.int, 0)

    member = sym.addLibMethod("sleepSec", sleepSec, NIL)
    member.addMember("sec", Symbol.int, 0)

    member = sym.addLibMethod("malloc", malloc, Symbol.string)
    member.addMember("size", Symbol.int, 0)

    member = sym.addLibMethod("realloc", realloc, Symbol.string)
    member.addMember("buf", Symbol.string, 0)
    member.addMember("size", Symbol.int, 0)

    RETURN sym
  }

  # int SYS.shell(String command)
  PROC shell(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    # Flush stdout, the system command is likely to echo something, we
    # don't want to mess up the order.
    ctx.out.write("fflush(stdout), ")
    ctx.out.write("system(")
    genExpr(arg_node, ctx, Symbol.string)
    ctx.out.write(")")
  }

  # SYS.sleep(int usec)
  PROC sleep(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    useZsleep = TRUE
    ctx.scope.addUsedItem("time.h")
    ctx.out.write("Zsleep(")
    genExpr(arg_node, ctx, Symbol.int)
    ctx.out.write(")")
  }

  # SYS.sleepSec(int sec)
  PROC sleepSec(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    useZsleep = TRUE
    ctx.scope.addUsedItem("time.h")
    ctx.out.write("Zsleep((")
    genExpr(arg_node, ctx, Symbol.int)
    ctx.out.write(") * 1000000LL)")
  }

  # String buf = SYS.malloc(int size)
  PROC malloc(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    ctx.out.write("malloc(")
    genExpr(arg_node, ctx, Symbol.int)
    ctx.out.write(")")
  }

  # String newbuf = SYS.realloc(String oldbuf, int size)
  PROC realloc(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    ctx.out.write("realloc(")
    IF arg_node.n_type != Node.Type.op_comma
      arg_node.error("expected more arguments to realloc()")
    ELSE
      genExpr(arg_node.n_left, ctx, Symbol.string)
      ctx.out.write(", ")
      genExpr(arg_node.n_right, ctx, Symbol.int)
      ctx.out.write(")")
      arg_node.n_undefined = arg_node.n_left.n_undefined
                                                + arg_node.n_right.n_undefined
    }
  }

  FUNC Symbol genExpr(Node node, SContext ctx, Symbol destSym)
    RETURN Generate.genExpr(node, ctx, destSym)
  }

  PROC writeBody(Scope topScope, IO.File fd)
    IF useZsleep
      # TODO: not all systems have nanosleep()
      fd.write('''
void Zsleep(Zint usec) {
  struct timespec tm;
  tm.tv_sec = usec / 1000000;
  tm.tv_nsec = (usec % 1000000) * 1000;
  nanosleep(&tm, NULL);
}
''')
    }
  }

}
