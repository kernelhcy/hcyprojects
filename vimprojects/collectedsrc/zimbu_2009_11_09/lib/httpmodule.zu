#
# The Zimbu compiler written in Zimbu
#
# builtin module HTTP
#
# TODO: confirm to HTTP/1.1  http://www.w3.org/Protocols/rfc2616/rfc2616.html
#
# Copyright 2009 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

MODULE HTTPmodule
  ENUM RequestType  # according to HTTP/1.1; uppercase in request
    options
    get
    head
    post
    put
    delete
    trace
    connect
  }
  CLASS Request
    RequestType          type
    dict<string, string> headerItems
    string               path
    string               params  # ?arg=val&arg=val  without the ?
  }

  CLASS Response
    int                  code    # 200 (OK), 404 (not found), etc.
    string               msg     # human readable message related to "code"
    dict<string, string> headerItems
    string               body

    # Create default header with OK code and HTML type.
    NEW()
      code = 200
      msg = "OK"
      headerItems = NEW()
      setType("text/html; charset=utf-8")
      body = "empty\n"
    }

    PROC setLength(int length)
      headerItems["Content-Length"] = length
    }

    PROC setType(string type)
      headerItems["Content-Type"] = type
    }
  }

  CLASS.abstract Servlet
    string       name
    list<string> paths    # TODO: also add patterns.
    string       mimeType

    # Add a path that this servlet will serve for.
    PROC addPath(string path)
      IF paths == NIL
        paths = NEW()
      }
      paths.add(path)
    }

    # Check if this servlet wants to serve the |req|.
    # If so, put the result in |resp| and return TRUE.
    # If not return FALSE.
    FUNC bool handle(Server server, Request req, Response resp)
      IF paths != NIL
        FOR p IN paths
          IF p == req.path
            IF mimeType != NIL
              resp.setType(mimeType)
            }
            serve(server, req, resp)
            RETURN TRUE
          }
        }
      }
      RETURN FALSE
    }

    PROC setMimeType(string type)
      mimeType = type
    }

    # serve the |req|, put the reply in |resp|
    PROC.abstract serve(Server server, Request req, Response resp)
  }

  # Get the body from a file.
  # TODO: Caching
  CLASS FileServlet EXTENDS Servlet
    string fileName
    NEW(string _fileName)
      name = "FileServlet"
      fileName = _fileName
    }

    PROC setFile(string _fileName)
      fileName = _fileName
      # TODO: detect MIME type from file name, call setMimeType()
    }

    DEFINE PROC serve(Server server, Request req, Response resp)
      # Add file contents to resp.
      IO.writeLine("reading " .. server.fileRoot .. "/" .. fileName)
      resp.body = IO.readFile(server.fileRoot .. "/" .. fileName)
      # TODO: stat file
      # resp.headerItems["Last-Modified"] = stat.time
    }
  }

  # Get the body from a string.
  CLASS StringServlet EXTENDS Servlet
    string body
    NEW(string _body)
      name = "StringServlet"
      body = _body
    }

    PROC setBody(string _body)
      body = _body
    }

    DEFINE PROC serve(Server server, Request req, Response resp)
      resp.body = body
    }
  }

  # Generate the body with a function.
  CLASS FunctionServlet EXTENDS Servlet
    func<string, Request, Response> serveFunc
    NEW(func<string, Request, Response> func)
      name = "FunctionServlet"
      serveFunc = func
    }

    PROC setProc(func<string, Request, Response> func)
      serveFunc = func
    }

    DEFINE PROC serve(Server server, Request req, Response resp)
      resp.body = serveFunc(req, resp)
    }
  }

  # The HTTP server.
  CLASS Server EXTENDS thread
    int port
    int listenQueueLen = 50
    list<Servlet.I> servlets
    string fileRoot

    NEW(int _port)
      port = _port
      servlets = NEW()
    }

    PROC addServlet(Servlet.I servlet)
      servlets.add(servlet)
    }

    REPLACE PROC body()
      # Open TCP server socket on "port", start listening.
      string reqString
      int listenArg = listenQueueLen
>>>
      int serv_fd;
      serv_fd = socket(AF_INET, SOCK_STREAM, 0);
      if (serv_fd == -1) {
        perror("HTTP server socket");
        return;
      }
      {
        int on = 1;
        if (setsockopt(serv_fd, SOL_SOCKET, SO_REUSEADDR,
                                                     &on, sizeof(on)) == -1) {
          perror("HTTP server setsockopt");
          return;
        }
      }
      {
        struct sockaddr_in serv_addr;
        memset(&serv_addr, 0, sizeof(struct sockaddr_in));
        serv_addr.sin_family = AF_INET;
        serv_addr.sin_addr.s_addr = INADDR_ANY;
        serv_addr.sin_port = htons((int)THIS->Vport);
        if (bind(serv_fd, (struct sockaddr *)&serv_addr,
                                                   sizeof(serv_addr)) == -1) {
          perror("HTTP server bind");
          return;
        }
      }

      if (listen(serv_fd, VlistenArg) == -1) {
        perror("HTTP server listen");
        return;
      }
      while (1) {
        struct sockaddr_in client_addr;
        int fd;
  #define MAX_HEADER_SIZE 4100
        char req_string[MAX_HEADER_SIZE];
        socklen_t addr_len = sizeof(client_addr);
        int len;

        fd = accept(serv_fd, (struct sockaddr *)&client_addr, &addr_len);
        if (fd == -1) {
          perror("HTTP server accept");
          return;
        }
        len = read(fd, req_string, MAX_HEADER_SIZE - 1);
        if (len < 0) {
          perror("HTTP server read");
          return;
        }
        req_string[len] = 0;
        VreqString = req_string;
<<<
        Request req = NEW()
        int si = reqString.index(' ')
        # TODO: parse the request: GET, POST, HEAD
        req.type = RequestType.get

        WHILE reqString[si] == ' '
          si++
        }
        int ei = si
        WHILE reqString[ei] != ' ' && reqString[ei] != 0
          ei++
        }
        req.path = reqString.slice(si, ei - 1)
        int qi = req.path.index('?')
        IF qi >= 0
          # separate out ?arg=val&arg=val
          req.params = req.path.slice(qi + 1, -1)
          req.path = req.path.slice(0, qi - 1)
        }

        IO.writeLine("Received HTTP request " .. reqString.slice(0, ei - 1))

        # Request received, find servlet to serve it.
        Response resp = NEW()
        bool done
        FOR servlet IN servlets
          IF servlet.handle(THIS, req, resp)
            done = TRUE
            BREAK
          }
        }
        IF !done
          resp.code = 404
          resp.msg = "Page not found."
          resp.body = "Sorry, this page is not available.\n"
        }
        resp.setLength(resp.body.SIZE())

        # Send response.
        # TODO: USE CRLF for line separator
        # TODO: encode special characters
        string respString = "HTTP/1.1 " .. resp.code .. " " .. resp.msg .. "\r\n"
        int respLen
        FOR key IN resp.headerItems.keys()
          respString ..= key .. ": " .. resp.headerItems.get(key) .. "\r\n"
        }
        respLen = respString.SIZE()
        # TODO: logging
        IO.writeLine("Sending HTTP response " .. resp.code)
>>>
        if (write(fd, VrespString, (size_t)VrespLen) <= 0) {
          perror("write header");
          return;
        }
<<<
        IF req.type != RequestType.head
          respString = resp.body
          respLen = respString.SIZE()
>>>
          if (write(fd, "\r\n", 2) != 2) {
            perror("write separator");
            return;
          }
          if (write(fd, VrespString, (size_t)VrespLen) <= 0) {
            perror("write body");
            return;
          }
<<<
        }
>>>
        close(fd);
     }  /* while */
<<<
    }
  }

}
