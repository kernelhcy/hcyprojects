#
# The Zimbu compiler written in Zimbu
#
# IO module
#
# Copyright 2009 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT "../generate.zu"
IMPORT "../node.zu"
IMPORT "../output.zu"
IMPORT "../scontext.zu"
IMPORT "../scope.zu"
IMPORT "../symbol.zu"
IMPORT "../write_c.zu"

MODULE LibIO

  Symbol fileSym

  # Return the symbol for the module.  The members of this symbol contain all
  # the items that the module defines.
  FUNC Symbol getSymbol()
    Symbol sym = NEW(Node.Type.lib_module)
    sym.name = "IO"
    sym.cName = "MIO"
    Write_C.includeWriters.add(writeInclude)
    Write_C.typedefWriters.add(writeTypedef)
    Write_C.declWriters.add(writeDecl)
    Write_C.bodyWriters.add(writeBody)

    # reading and writing stdin/stdout
    Symbol member
    member = sym.addLibMethod("readByte", readByte, Symbol.int)

    member = sym.addLibMethod("readFile", readFile, Symbol.string)
    member.addMember("fileName", Symbol.string, 0)

    member = sym.addLibMethod("write", write, Symbol.int)
    member.addMember("text", Symbol.string, 0)

    member = sym.addLibMethod("writeLine", writeLine, Symbol.int)
    member.addMember("text", Symbol.string, 0)

    member = sym.addLibMethod("writeByte", writeByte, Symbol.int)
    member.addMember("byte", Symbol.int, 0)

    member = sym.addLibMethod("flush", flush, Symbol.int)

    # Define IO.File
    fileSym = NEW(Node.Type.class)
    fileSym.name = "File"
    fileSym.class = fileSym
    fileSym.cName = "FILE"
    fileSym.className = "FILE"
    sym.addMember(fileSym)
    member = fileSym.addLibMethod("readByte", fileReadByte, Symbol.int)
    member = fileSym.addLibMethod("write", fileWrite, NIL)
    member.addMember("text", Symbol.string, 0)
    member = fileSym.addLibMethod("writeByte", fileWriteByte, NIL)
    member.addMember("byte", Symbol.int, 0)
    member = fileSym.addLibMethod("close", fileClose, NIL)

    # opening a file for reading/writing
    fileSym = fileSym.copyObject()
    member = sym.addLibMethod("fileReader", fileReader, fileSym)
    member.addMember("fileName", Symbol.string, 0)

    member = sym.addLibMethod("fileWriter", fileWriter, fileSym)
    member.addMember("fileName", Symbol.string, 0)

    # EOF is hard coded.
    sym.addMember("eof", NEW(Node.Type.int), 0).cName = "MIO__Veof"

    # renaming/deleting files/directories
    member = sym.addLibMethod("rename", rename, Symbol.int)
    member.addMember("fromName", Symbol.string, 0)
    member.addMember("toName", Symbol.string, 0)

    member = sym.addLibMethod("delete", delete, Symbol.int)
    member.addMember("fileName", Symbol.string, 0)

    member = sym.addLibMethod("mkdir", mkdir, Symbol.int)
    member.addMember("dirName", Symbol.string, 0)

    # Define IO.Stat and IO.stat()
    Symbol statSym = NEW(Node.Type.class)
    statSym.name = "Stat"
    statSym.class = statSym
    statSym.cName = "MIO__CStat"
    statSym.className = "MIO__CStat"
    statSym.addMember("size", Symbol.int, 0).cName = "size"
    statSym.addMember("time", Symbol.int, 0).cName = "time"
    sym.addMember(statSym)

    statSym = statSym.copyObject()
    member = sym.addLibMethod("stat", stat, statSym)
    member.addMember("fileName", Symbol.string, 0)

    RETURN sym
  }

  # int IO.readByte()
  PROC readByte(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    ctx.out.write("fgetc(stdin)")
  }

  # string IO.readFile(fileName)
  PROC readFile(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    ctx.scope.addUsedItem("IO.readFile")
    ctx.scope.addUsedItem("fcntl.h")
    ctx.scope.addUsedItem("sys/types.h")
    ctx.scope.addUsedItem("unistd.h")
    ctx.out.write("ZreadFile(")
    genExpr(arg_node, ctx, Symbol.string)
    ctx.out.write(")")
  }

  # int IO.write(String text)
  PROC write(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    ctx.out.write("fputs(")
    genExpr(arg_node, ctx, Symbol.string)
    ctx.out.write(", stdout)")
  }

  # int IO.writeLine(String text)
  PROC writeLine(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    ctx.out.write("(fputs(")
    genExpr(arg_node, ctx, Symbol.string)
    ctx.out.write(", stdout) | fputc('\\n', stdout))")
  }

  # int IO.writeByte(int byte)
  PROC writeByte(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    ctx.out.write("fputc(")
    genExpr(arg_node, ctx, Symbol.int)
    ctx.out.write(", stdout)")
  }

  # int IO.flush()
  PROC flush(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    ctx.out.write("fflush(stdout)")
  }

  # IO.File.readByte()
  PROC fileReadByte(Symbol sym, Symbol class, Node m_node, SContext ctx)
    ctx.out.write("fgetc(")
    generateVarname(m_node.n_left.n_left, ctx, fileSym)
    ctx.out.write(")")
    m_node.n_undefined = m_node.n_left.n_left.n_undefined
  }

  # IO.File.write()
  PROC fileWrite(Symbol sym, Symbol class, Node m_node, SContext ctx)
    ctx.out.write("fputs(")
    genExpr(m_node.n_right, ctx, Symbol.string)
    ctx.out.write(", ")
    generateVarname(m_node.n_left.n_left, ctx, fileSym)
    ctx.out.write(")")
    m_node.n_undefined = m_node.n_right.n_undefined
                                            + m_node.n_left.n_left.n_undefined
  }

  # IO.File.writeByte()
  PROC fileWriteByte(Symbol sym, Symbol class, Node m_node, SContext ctx)
    ctx.out.write("fputc(")
    genExpr(m_node.n_right, ctx, Symbol.int)
    ctx.out.write(", ")
    generateVarname(m_node.n_left.n_left, ctx, fileSym)
    ctx.out.write(")")
    m_node.n_undefined = m_node.n_right.n_undefined
                                            + m_node.n_left.n_left.n_undefined
  }

  # IO.File.close()
  PROC fileClose(Symbol sym, Symbol class, Node m_node, SContext ctx)
    ctx.out.write("fclose(")
    generateVarname(m_node.n_left.n_left, ctx, fileSym)
    ctx.out.write(")")
    m_node.n_undefined = m_node.n_left.n_left.n_undefined
  }

  # IO.File IO.fileReader(String fileName)
  PROC fileReader(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    ctx.out.write("fopen(")
    genExpr(arg_node, ctx, Symbol.string)
    ctx.out.write(", \"r\")")
  }

  # IO.File IO.fileWriter(String fileName)
  PROC fileWriter(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    ctx.out.write("fopen(")
    genExpr(arg_node, ctx, Symbol.string)
    ctx.out.write(", \"w\")")
  }

  # int IO.rename(from, to)
  PROC rename(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    ctx.out.write("rename(")
    genExpr(arg_node.n_left, ctx, Symbol.string)
    ctx.out.write(", ")
    genExpr(arg_node.n_right, ctx, Symbol.string)
    ctx.out.write(")")
  }

  # int IO.delete(fname)
  PROC delete(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    ctx.scope.addUsedItem("unistd.h")
    ctx.out.write("unlink(")
    genExpr(arg_node, ctx, Symbol.string)
    ctx.out.write(")")
  }

  # int IO.mkdir(String dirName)
  # TODO: optional argument to specify protection
  # TODO: default to create directories recursively
  PROC mkdir(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    ctx.scope.addUsedItem("sys/types.h")
    ctx.scope.addUsedItem("sys/stat.h")
    # On MS-Windows mkdir() takes only one argument.
    ctx.out.write("\n#if defined(__MINGW32__) || defined(_MSC_VER)\n")
    ctx.out.write("_mkdir(")
    genExpr(arg_node, ctx, Symbol.string)
    ctx.out.write(")\n")
    ctx.out.write("#else\n")
    ctx.out.write("mkdir(")
    genExpr(arg_node, ctx, Symbol.string)
    ctx.out.write(", 0777)\n")
    ctx.out.write("#endif\n")
  }

  # Stat IO.stat()
  PROC stat(Symbol sym, Symbol class, Node arg_node, SContext ctx)
    ctx.scope.addUsedItem("sys/stat.h")
    ctx.scope.addUsedItem("alloc")
    useZStat = TRUE
    ctx.out.write("ZStat(")
    genExpr(arg_node, ctx, Symbol.string)
    ctx.out.write(")")
  }

  FUNC Symbol generateVarname(Node node, SContext ctx, Symbol destSym)
    RETURN Generate.generateVarname(node, ctx, destSym)
  }

  FUNC Symbol genExpr(Node node, SContext ctx, Symbol destSym)
    RETURN Generate.genExpr(node, ctx, destSym)
  }

  bool useZStat

  PROC writeInclude(Scope topScope, IO.File fd)
  }

  PROC writeTypedef(Scope topScope, IO.File fd)
    IF useZStat
      fd.write('''
typedef struct MIO__CStat__S MIO__CStat;
''')
    }
  }

  PROC writeDecl(Scope topScope, IO.File fd)
    IF useZStat
      fd.write('''
struct MIO__CStat__S {
  size_t size;
  long   time;
};
''')
    }
  }

  PROC writeBody(Scope topScope, IO.File fd)
    IF useZStat
      fd.write('''
MIO__CStat *ZStat(char *name) {
  MIO__CStat *res = Zalloc(sizeof(MIO__CStat));
  struct stat st;
  if (stat(name, &st) == 0) {
    res->size = st.st_size;
    res->time = st.st_mtime;
  }
  return res;
}
''')
    }

    IF topScope.usedItems.has("IO.readFile")
      fd.write('''
char *ZreadFile(char *fileName) {
  off_t len;
  char *res;
  int fd = open(fileName, O_RDONLY, 0);
  if (fd < 0) {
    perror("readFile open");
    return "";
  }
  len = lseek(fd, 0, SEEK_END);
  if (len < 0) {
    perror("readFile lseek");
    close(fd);
    return "";
  }
  if (lseek(fd, 0, SEEK_SET) < 0) {
    perror("readFile reset");
    close(fd);
    return "";
  }
  res = malloc(len + 1);
  if (read(fd, res, len) != len) {
    perror("readFile read");
    close(fd);
    return "";
  }
  res[len] = 0;
  close(fd);
  return res;
}
''')
    }
  }
}
