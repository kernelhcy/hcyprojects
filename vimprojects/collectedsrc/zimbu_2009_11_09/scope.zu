#
# The Zimbu compiler written in Zimbu
#
# Scope module.
#
# A Scope is independent of the target language.  It can used to produce C, JS
# or both.  Thus there must be nothing in here that works for only one target
# language.
#
# Copyright 2009 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT "builtin.zu"
IMPORT "error.zu"
IMPORT "generate.zu"
IMPORT "node.zu"
IMPORT "output.zu"
IMPORT "symbol.zu"
IMPORT "tokenize.zu"
IMPORT "usedfile.zu"
IMPORT "zimbufile.zu"

IMPORT "lib/libarg.zu"
IMPORT "lib/libio.zu"
IMPORT "lib/libsys.zu"
IMPORT "lib/libthread.zu"

CLASS Scope
  Scope     outer           # Scope that contains this one, NIL for toplevel
  ZimbuFile zimbuFile       # toplevel in a file only: info about the file
  string    dirName         # for toplevel only

  int       pass            # pass number: 1, 2, 3, etc.  0 is used to
                            # produce code for a node in a different scope.
  int       depth           # depth used for indenting
  string    importIndent    # indent used for import messages
  Node      topNode         # top scope has node here after parsing
  Node.Type nodeType        # scope type, set for IF, FOR, SWITCH, etc.
  bool      statements      # can have statements, FALSE for toplevel, module
                            # and class
  list<Symbol> memberList   # symbols local to this scope
  list<ZimbuFile> importList  # list of imports for this scope
  string    skipPredefined  # symbol that must not be found in
                            # predefinedSymbols
  string    scopeName       # used for naming nested items
  Symbol    class           # class we are currently inside, use "THIS" for
                            # class-local variables
  bool      insideNew       # inside NEW function
  string    thisName        # what to use for THIS, NIL if THIS cannot be used.
  bool      insideShared    # inside SHARED section
  string    moduleName      # set if this is the scope of a module
  Symbol    returnSymbol    # used for RETURN
  Symbol    switchSymbol    # used for CASE inside SWITCH
  list<string>  caseList    # values generated for CASE
  bool      init            # init variables when declared
  bool      forwardDeclare  # symbols can be used before defined
  bool      noGenerate      # no code is currently being generated

  # Keep track of which Token.Type.id keywords have been used in this file.
  # This is for loading a built-in library only when it is used.
  # Only not NIL for a scope at the file level
  dict<string, bool> usedIdKeywords # TODO: this should be type set<string>

  # Keep track of which extra items are used in this file.
  dict<string, bool> usedItems      # TODO: this should be type set<string>

  # Return TRUE when in a class scope, not in SHARED section inside a class.
  FUNC bool isClassScope()
    RETURN class != NIL && !insideShared
  }

  # Find |name| in the symbols of this scope and outer scopes.
  FUNC Symbol getSymbol(string name)
    RETURN getSymbol(name, Node.Type.unknown, TRUE, NIL)
  }

  # Idem, only check for using class member when |classCheck| is TRUE.
  FUNC Symbol getSymbol(string name, bool classCheck)
    RETURN getSymbol(name, Node.Type.unknown, classCheck, NIL)
  }

  FUNC Symbol getSymbol(string name, Node node)
    RETURN getSymbol(name, Node.Type.unknown, TRUE, node)
  }

  FUNC Symbol getSymbol(string name, Node.Type type,
                                                 bool classCheck, Node node)
    Symbol sym
    IF name != skipPredefined
      # Search in predefined symbols
      sym = findPredefinedSymbol(name, type)
    }

    IF sym == NIL
      # Search in local and imported symbols.
      sym = getSymbolInt(name, type, insideShared, classCheck, node)
    }
    RETURN sym
  }

  FUNC Symbol getSymbolInt(string name, Node.Type type, bool inShared,
                                                 bool classCheck, Node node)
    # Search in current scope.
    # If the symbol is used in a SHARED section and it is defined in the
    # class scope give an error.
    Symbol sym = Symbol.find(memberList, name, type)
    IF sym != NIL && classCheck && inShared && class != NIL
                    && (sym.className != NIL && sym.type != Node.Type.class)
      sym = NIL
      IF node != NIL
        node.error("Cannot use class member in SHARED section")
      }
    }

    # Search in scope of parent class.
    IF sym == NIL && isClassScope() && class.parentClass != NIL
      sym = class.parentClass.findMember(name, type)
    }

    IF sym == NIL && importList != NIL
      # Search in imported symbols.
      FOR import IN importList
        IF import.topScope != NIL
          sym = Symbol.find(import.topScope.memberList, name, type)
          IF sym != NIL
            BREAK
          }
        }
      }
    }

    IF sym != NIL
      RETURN sym
    }

    # Search in outer scopes.
    IF outer != NIL
      RETURN outer.getSymbolInt(name, type, inShared, classCheck, node)
    }
    RETURN NIL
  }

  # Return TRUE if this scope was used in an IMPORT.ZWT.
  FUNC bool usedAsZwt()
    IF zimbuFile != NIL
      RETURN zimbuFile.usedAsZwt
    }
    IF outer != NIL
      RETURN outer.usedAsZwt()
    }
    RETURN FALSE
  }

  # Return TRUE if this scope was used in an IMPORT.
  FUNC bool usedAsZimbu()
    IF zimbuFile != NIL
      RETURN zimbuFile.usedAsZimbu
    }
    IF outer != NIL
      RETURN outer.usedAsZimbu()
    }
    RETURN FALSE
  }

  # Return the Symbol for |node| if it's an ID, a member of an ID, etc.
  # Return NIL when it is something else.
  FUNC Symbol findNodeSymbol(Node node)
    RETURN findNodeSymbol(node, Node.Type.unknown, FALSE)
  }

  # Note: does not reset node.n_undefined, only increments it.
  FUNC Symbol findNodeSymbol(Node node, Node.Type type, bool error)
    SWITCH node.n_type
      CASE Node.Type.id
        Symbol sym = getSymbol(node.n_string, type, TRUE, node)
        IF sym == NIL
          node.n_undefined++
          IF error
            node.error("Symbol not found: " .. node.n_string)
          }
        ELSEIF sym.type == Node.Type.ref && sym.returnSymbol != NIL
          sym = sym.returnSymbol
        }
        RETURN sym
      CASE Node.Type.member
        Symbol sym = findNodeSymbol(node.n_left, type, error)
        IF sym != NIL
          Symbol s
          IF node.n_string == "I"
            IF sym.type == Node.Type.module && sym.getMemberList() != NIL
              # Looking for a class and found a module: find class in the
              # module with the same name.
              Symbol cs = Symbol.find(sym.getMemberList(),
                                      node.n_left.n_string, Node.Type.class)
              IF cs != NIL
                sym = cs
              }
            }
            IF sym.type != Node.Type.class
              node.n_undefined++
              IF error
                node.n_left.error("Class expected")
              }
            }
            s = NEW(Node.Type.i_object)
            s.class = sym
          ELSE
            s = sym.findMember(node.n_string)
            IF s == NIL
              node.n_undefined++
              IF error
                IF sym.getMemberList() == NIL
                  node.error("Symbol has no members: " .. node.n_left.n_string)
                ELSE
                  node.error("Member " .. node.n_string .. " not found in "
                                                     .. node.n_left.n_string)
                }
              }
            }
          }
          RETURN s
        }
      DEFAULT
        node.n_undefined++
        IF error
          node.error("Unexpected node type: " .. node.n_type.name())
        }
    }
    RETURN NIL
  }

  # Add |import| to the list of imports
  PROC addImport(ZimbuFile import)
    IF importList == NIL
      importList = NEW()
    }
    importList.add(import)
  }

  # Find |name| in the symbols of this scope and outer scopes and return its
  # type.
  FUNC Node.Type getSymbolType(string name)
    Symbol sym = getSymbol(name)
    IF sym != NIL
      RETURN sym.type
    }
    RETURN Node.Type.unknown
  }

  # If |name| is a predefined type name, return that type.
  # Otherwise find |name| in the symbols of this scope and outer scopes and
  # return its type.
  FUNC Node.Type getAType(string name)
    Node.Type type = Node.name2Type(name)
    IF type == Node.Type.unknown
      type = getSymbolType(name)
    }
    RETURN type
  }

  # Add a symbol to the head of the list (they will be in reverse order).
  # Unless the symbol is already there: in the second round for scopes where
  # forward declarations are possible.
  # In the second round node.n_symbol is re-used IF it's set.
  # Return the new symbol.
  FUNC Symbol addSymbol(string name, Node.Type type, Node node, bool dupOk)
    Symbol newSym = NIL
    bool   doAdd = TRUE
    Symbol oldSym
    IF !dupOk
      # Search for "NEW", "SIZE" and "EQUAL" only in the current scope.
      # Also for the module name itself, when used as a class name.
      IF name == "NEW" || name == "SIZE" || name == "EQUAL"
         || (type == Node.Type.class
                                 && moduleName != NIL && name == moduleName)
        oldSym = Symbol.find(memberList, name)
      ELSE
        # We can have one module and one class with the same name.
        oldSym = getSymbol(name)
      }
    }
    IF pass > 1 && forwardDeclare
      # In the second round find the symbol that we already added in the
      # first round.  However, the type may be different now, so set the
      # values anyway.
      IF oldSym == NIL
        node.error("INTERNAL: Symbol not found in second round: " .. name)
      ELSE
        newSym = oldSym
        doAdd = FALSE
      }
    ELSE
      IF oldSym != NIL
        IF oldSym.pos != NIL
          node.error("Symbol already defined in line " .. oldSym.pos.lnum
                                                              .. ": " .. name)
        ELSE
          node.error("Duplicate Symbol: " .. name)
        }
      ELSEIF !forwardDeclare && node.n_symbol != NIL
        # Re-use the symbol from the first round.
        newSym = node.n_symbol
      }
    }

    IF newSym == NIL
      newSym = NEW(type)
    ELSE
      newSym.type = type
    }
    newSym.name = name
    newSym.pos = node.n_start
    IF doAdd
      IF memberList == NIL
        memberList = NEW()
      }
      # TODO: should not depend on order, add() doesn't work.
      memberList.insert(newSym)
    }
    RETURN newSym
  }

  # append |sym| to the list of members.
  PROC addMember(Symbol sym)
    IF memberList == NIL
      memberList = NEW()
    }
    memberList.add(sym)
  }

  # Like addSymbol above, but use a Symbol instead of a type.
  # Also copies the detail information from |sp| to the new Symbol.
  # When the scope is a class also put the class in the symbol
  FUNC Symbol addSymbol(string name, Symbol sp, Node node, bool dupOk)
    Symbol sym = addSymbol(name,
                       sp == NIL ? Node.Type.unknown : sp.type, node, dupOk)
    IF !isClassScope() || statements
      sym.className = NIL
    ELSE
      sym.className = class.className
    }
    IF sp != NIL
      sym.memberList = sp.memberList
      sym.children = sp.children
      sym.class = sp.class                # for Class and Enum
      sym.parentClass = sp.parentClass    # for Class
      sym.keySymbol = sp.keySymbol        # for Dict
      sym.returnSymbol = sp.returnSymbol  # for list and array
    }
    RETURN sym
  }

  # Find a function (proc/NEW/etc.) with name |name| that matches the
  # argument list |argList|.  Skip Symbol |skip| (can be NIL).
  # When |searchOuter| is FALSE only uses the this scope, not outer ones.
  FUNC Symbol findMatchingFunc(string name,
                               list<Symbol> argList,
                               Symbol skip,
                               bool searchOuter,
                               bool convert)
    IF Error.debug
      IO.writeLine("findMatchingFunc() " .. name)
    }
    bool foundSkip
    Symbol sym = Symbol.findMatchingFunctionInList(memberList, name,
                                         argList, skip, &foundSkip, convert)
    IF sym == NIL && searchOuter && outer != NIL
      sym = outer.findMatchingFunc(name, argList, skip, TRUE, convert)
    }
    RETURN sym
  }

  # List matching functions (proc/NEW/etc.) with name |name|.
  # When |all| is false only those that match the argument list |argList|.
  PROC listMatchingFunc(string name, list<Symbol> argList, bool all)
    IF memberList != NIL
      FOR m IN memberList
        IF m.name == name
          # TODO: if !all check arguments match
          IO.write("Candidate: " .. name)
          Generate.listArgTypes(m.memberList)
        }
      }
    }
    IF outer != NIL
      outer.listMatchingFunc(name, argList, all)
    }
  }

  FUNC Node.Type getReturnType()
    IF returnSymbol == NIL
      RETURN Node.Type.unknown
    }
    RETURN returnSymbol.type
  }

  # Add a used item |name|.
  PROC addUsedItem(string name)
    IF usedItems == NIL
      IF outer != NIL
        outer.addUsedItem(name)
      ELSE
        Error.report("INTERNAL: can't find usedItems")
      }
    ELSE
      usedItems[name] = TRUE
    }
  }

  # Merge used ID keywords and items from |scope|.
  PROC mergeKeywords(Scope scope)
    IF usedIdKeywords == NIL
      IF outer != NIL
        outer.mergeKeywords(scope)
      ELSE
        Error.report("INTERNAL: can't find usedIdKeywords")
      }
    ELSE
      FOR key IN scope.usedIdKeywords.keys()
        IF !usedIdKeywords.has(key)
          usedIdKeywords[key] = TRUE
        }
      }
      FOR key IN scope.usedItems.keys()
        IF !usedItems.has(key)
          usedItems[key] = TRUE
        }
      }
    }
  }

  SHARED

    #
    # Predefined symbols
    #
    list<Symbol>        predefinedSymbols

    FUNC Symbol findPredefinedSymbol(string name, Node.Type type)
      IF predefinedSymbols == NIL
        loadPredefinedSymbols()
      }
      FOR sym IN predefinedSymbols
        IF sym.matches(name, type)
          RETURN sym
        }
      }
      RETURN NIL
    }

    PROC loadPredefinedSymbols()
      predefinedSymbols = NEW()

      # Define library modules and classes.
      predefinedSymbols.add(LibARG.getSymbol())
      predefinedSymbols.add(LibIO.getSymbol())
      predefinedSymbols.add(LibSYS.getSymbol())
      predefinedSymbols.extend(LibTHREAD.getSymbols())
    }

    # Called for builtin modules loaded only when used.
    PROC addPredefinedSymbol(Symbol sym)
      IF predefinedSymbols == NIL
        loadPredefinedSymbols()
      }
      predefinedSymbols.add(sym)
    }

    # Create a new scope, with |outer| as the outer scope (can be NIL)
    # |forwardDeclare| means symbols are kept from the first round to the
    # second, so that symbols can be used before declared.
    FUNC Scope newScope(Scope outer, bool forwardDeclare)
      Scope scope = NEW()
      IF outer != NIL
        scope.outer = outer
        scope.depth = outer.depth + 1
        scope.returnSymbol = outer.returnSymbol
        scope.statements = TRUE
        scope.pass = outer.pass
        scope.class = outer.class
        scope.insideNew = outer.insideNew
        scope.thisName = outer.thisName
        scope.insideShared = outer.insideShared
        scope.noGenerate = outer.noGenerate
      }
      scope.init = TRUE
      scope.forwardDeclare = forwardDeclare
      RETURN scope
    }
  }
}
