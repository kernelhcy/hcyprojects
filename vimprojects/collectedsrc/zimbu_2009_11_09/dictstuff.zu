#
# The Zimbu compiler written in Zimbu
#
# Stuff for Dict
#
# Copyright 2009 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT "error.zu"
IMPORT "generate.zu"
IMPORT "liststuff.zu"
IMPORT "node.zu"
IMPORT "output.zu"
IMPORT "scontext.zu"
IMPORT "scope.zu"
IMPORT "symbol.zu"

MODULE DictStuff

  bool useDict
  bool useZDictHas
  bool useZDictRemove
  bool useZDictFind
  bool useZDictGetPtr
  bool useZDictGetPtrDef
  bool useZDictGetInt
  bool useZDictGetIntDef
  bool useZDictToString
  bool useZDictKeys
  bool useZDictCopy
  bool useZDictClear

  FUNC Symbol generateMethodCall(Symbol sp, Node m_node, SContext ctx,
                                                               Symbol destSym)
    Node node = m_node.n_left
    Node var_node = node.n_left
    Node arg_node = m_node.n_right
    string method = node.n_string
    Symbol ret = NEW(Node.Type.unknown)
    IF method == "toString"
      IF Error.checkArgCount(arg_node, 0, 0, method) == OK
        ctx.scope.addUsedItem("int2string")
        ctx.scope.addUsedItem("garray")
        useZDictToString = TRUE
        ctx.out.write("ZDictToString(")
        generateVarname(var_node, ctx, sp)
        ctx.out.write(")")
        ret.type = Node.Type.string
      }
    ELSEIF method == "get"
      IF Error.checkArgCount(arg_node, 1, 2, method) == OK
        IF arg_node.n_type == Node.Type.op_comma
          ret = generateGet(sp, var_node, arg_node.n_left,
                                               arg_node.n_right, ctx, destSym)
        ELSE
          ret = generateGet(sp, var_node, arg_node, NIL, ctx, destSym)
        }
      }
    ELSEIF method == "has"
      IF Error.checkArgCount(arg_node, 1, 1, method) == OK
        useZDictHas = TRUE
        ctx.out.write("ZDictHas(")
        generateVarname(var_node, ctx, sp)
        genKeyArgs(sp.keySymbol, arg_node, ctx)
        ctx.out.write(")")
        ret.type = Node.Type.bool
      }
    ELSEIF method == "add"
      IF Error.checkArgCount(arg_node, 2, 2, method) == OK
        ctx.out.write("ZDictAdd(0, ")
        generateVarname(var_node, ctx, sp)
        genKeyArgs(sp.keySymbol, arg_node.n_left, ctx)
        genKeyArgs(sp.returnSymbol, arg_node.n_right, ctx)
        ctx.out.write(")")
        ret.type = Node.Type.dict
        ret.keySymbol = sp.keySymbol
        ret.returnSymbol = sp.returnSymbol
      }
    ELSEIF method == "remove"
      IF Error.checkArgCount(arg_node, 1, 1, method) == OK
        useZDictRemove = TRUE
        ctx.out.write("ZDictRemove(")
        generateVarname(var_node, ctx, sp)
        genKeyArgs(sp.keySymbol, arg_node, ctx)
        ctx.out.write(")")
        ret.type = Node.Type.dict
        ret.keySymbol = sp.keySymbol
        ret.returnSymbol = sp.returnSymbol
      }
    ELSEIF method == "clear"
      IF Error.checkArgCount(arg_node, 0, 0, method) == OK
        useZDictClear = TRUE
        ctx.out.write("ZDictClear(")
        generateVarname(var_node, ctx, sp)
        ctx.out.write(")")
        ret.type = Node.Type.dict
        ret.keySymbol = sp.keySymbol
        ret.returnSymbol = sp.returnSymbol
      }
    ELSEIF method == "keys"
      IF Error.checkArgCount(arg_node, 0, 0, method) == OK
        useZDictKeys = TRUE
        ctx.scope.addUsedItem("list")
        ctx.scope.addUsedItem("listAdd")
        ctx.out.write("ZDictKeys(")
        generateVarname(var_node, ctx, sp)
        ctx.out.write(")")
        ret.type = Node.Type.list
        ret.returnSymbol = sp.keySymbol
      }
    ELSEIF method == "COPY"
      IF Error.checkArgCount(arg_node, 0, 0, method) == OK
        useZDictCopy = TRUE
        ctx.out.write("ZDictCopy(")
        generateVarname(var_node, ctx, sp)
        ctx.out.write(")")
        ret.type = Node.Type.dict
        ret.keySymbol = sp.keySymbol
        ret.returnSymbol = sp.returnSymbol
      }
    ELSEIF method == "SIZE"
      IF Error.checkArgCount(arg_node, 0, 0, method) == OK
        generateVarname(var_node, ctx, sp)
        ctx.out.write("->used")
      }
      ret.type = Node.Type.int
    ELSEIF Generate.doError(ctx.out)
      node.error("Method " .. method .. "() not supported for Dict")
    }
    RETURN ret
  }

  FUNC Symbol generateVarname(Node node, SContext ctx, Symbol destSym)
    RETURN Generate.generateVarname(node, ctx, destSym)
  }

  FUNC Symbol genExpr(Node node, SContext ctx, Symbol destSym)
    RETURN Generate.genExpr(node, ctx, destSym)
  }

  FUNC Symbol generateSubscript(Symbol sym, Node node, bool lvalue,
                                                 SContext ctx, Symbol destSym)
    # TODO: implement lvalue
    Symbol ret = generateGet(sym, node.n_left, node.n_right, NIL, ctx, destSym)
    node.n_undefined = node.n_left.n_undefined + node.n_right.n_undefined
    RETURN ret
  }

  FUNC Symbol generateGet(Symbol sym, Node dict_node, Node arg_node,
                       Node def_node, SContext ctx, Symbol destSym)
    string close = ")"
    IF sym.returnSymbol != NIL && sym.returnSymbol.isPointerType()
      # TODO: move to Symbol.typeCast(), also handle string
      IF sym.returnSymbol.type == Node.Type.class
        ctx.out.write("((" .. sym.returnSymbol.cName .. " *)")
        close = "))"
      ELSEIF sym.returnSymbol.type == Node.Type.i_object
        ctx.out.write("((Zoref *)")
        close = "))"
      }
      IF def_node == NIL
        useZDictGetPtr = TRUE
        ctx.out.write("ZDictGetPtr(")
      ELSE
        useZDictGetPtrDef = TRUE
        ctx.out.write("ZDictGetPtrDef(")
      }
    ELSE
      IF def_node == NIL
        useZDictGetInt = TRUE
        ctx.out.write("ZDictGetInt(")
      ELSE
        useZDictGetIntDef = TRUE
        ctx.out.write("ZDictGetIntDef(")
      }
    }
    useZDictFind = TRUE
    genExpr(dict_node, ctx, NIL)
    genKeyArgs(sym.keySymbol, arg_node, ctx)
    IF def_node != NIL
      ctx.out.write(", ")
      genExpr(def_node, ctx, sym.returnSymbol)
    }
    ctx.out.write(close)
    IF sym.returnSymbol != NIL
      RETURN sym.returnSymbol
    }
    RETURN destSym
  }

  # Generate the key/value argument for "sym".
  PROC genKeyArgs(Symbol sym, Node node, SContext ctx)
    ctx.out.write(", ")
    bool isPointer
    IF sym != NIL
      isPointer = sym.isPointerType()
    }
    IF isPointer
      ctx.out.write("0, ")
    }
    genExpr(node, ctx, sym != NIL ? sym : Symbol.int)
    IF !isPointer
      ctx.out.write(", NULL")
    }
  }

  # {key1 : value1, key2 : value2} ->
  #    ZDictAdd(0, ZDictAdd(0, GCNewDict(), Ikey1, Pkey1, Ivalue1, Pvalue1),
  #    Ikey2, Pkey2,  Ivalue2, Pvalue2)
  # TODO: check for duplicate keys at compile time.
  # Return type of dict in ret.keySymbol and ret.returnSymbol
  PROC generateDictPart_C(Node node, Symbol ret, SContext ctx)
    useDict = TRUE
    bool keyIsPointer
    ctx.out.write("ZDictAdd(0, ")
    IF node.n_type == Node.Type.op_comma
      generateDictPart_C(node.n_left, ret, ctx)
      IF ret.keySymbol != NIL
        keyIsPointer = ret.keySymbol.isPointerType()
      }
    ELSE
      Output noOut = NEW(NIL)
      ret.keySymbol = genExpr(node.n_cond, ctx.copyNoOut(), NIL)
      ret.returnSymbol = genExpr(node.n_right, ctx.copyNoOut(), NIL)
      IF ret.keySymbol != NIL
        keyIsPointer = ret.keySymbol.isPointerType()
      }
      IF keyIsPointer
        ctx.out.write("ZnewDict(1)")
      ELSE
        ctx.out.write("ZnewDict(0)")
      }
    }
    ctx.out.write(", ")
    # write the key argument
    IF keyIsPointer
      ctx.out.write("0, ")
    }
    genExpr(node.n_cond, ctx, ret.keySymbol)
    IF !ret.keySymbol.isPointerType()
      ctx.out.write(", NULL")
    }
    ctx.out.write(", ")
    # write the value argument
    IF ret.returnSymbol.isPointerType()
      ctx.out.write("0, ")
    }
    genExpr(node.n_right, ctx, ret.returnSymbol)
    IF !ret.returnSymbol.isPointerType()
      ctx.out.write(", NULL")
    }
    ctx.out.write(")")
  }

  PROC writeTypedefs(Scope topScope, IO.File fd)
    IF useDict
      fd.write('''
typedef unsigned long Zhashtype;
typedef struct CDictItem__S CDictItem;
typedef struct CDictHead__S CDictHead;
''')
    }
  }

  PROC writeDecl(Scope topScope, IO.File fd)
    IF useDict
      # Basic Dict definitions.
      fd.write('''
#define HT_INIT_SIZE 16
#define PERTURB_SHIFT 5

#define CDI_FLAG_PVAL 1
#define CDI_FLAG_USED 2
#define CDI_FLAG_DEL 4
struct CDictItem__S {
  Zhashtype hash;
  union {
    Zint Ikey;
    void *Pkey;
  };
  union {
    Zint Ival;
    void *Pval;
  };
  int flags;
};

struct CDictHead__S {
    Zhashtype   mask;
    Zhashtype   used;
    Zhashtype   filled;
    int         locked;
    CDictItem   *array;
    CDictItem   smallArray[HT_INIT_SIZE];
    int         usePkey;
};
''')
    }

  }

  PROC writeBody(Scope topScope, IO.File fd)
    IF useDict
      # Dict required functions.
      # The implementation mostly comes from src/hashtab.c in Vim.  For
      # comments on how it works see that file.
      fd.write('''
CDictHead *ZnewDict(int usePkey) {
  CDictHead *d = Zalloc(sizeof(CDictHead));
  d->array = d->smallArray;
  d->mask = HT_INIT_SIZE - 1;
  d->usePkey = usePkey;
  return d;
}

Zhashtype ZDictHash(CDictHead *d, Zint Ikey, unsigned char *Pkey) {
  if (d->usePkey) {
    Zhashtype hash = *Pkey;
    if (hash != 0) {
      unsigned char *p = Pkey + 1;
      while (*p != 0)
        hash = hash * 101 + *p++;
    }
    return hash;
  }
  return (Zhashtype)Ikey;
}

/* #define DICT_DEBUG 1 */

CDictItem *ZDictLookup(CDictHead *d, Zint Ikey, void *Pkey, Zhashtype hash)
{
  Zhashtype  perturb;
  CDictItem  *freeitem;
  CDictItem  *di;
  int        idx;
#ifdef DICT_DEBUG
  int        echo = Pkey != NULL && strcmp(Pkey, "EQUAL") == 0;
#endif

  idx = (int)(hash & d->mask);
  di = &d->array[idx];
#ifdef DICT_DEBUG
  if (echo)
    printf("idx = %d, flags = %d, key = %s, value = %lld\n",
    idx, di->flags, (char *)di->Pkey, di->Ival);
#endif

  if (di->flags == 0)
    return di;
  if (di->flags == CDI_FLAG_DEL)
    freeitem = di;
  /* TODO: other keys than string */
  else if (di->hash == hash && (d->usePkey
       ? (di->Pkey != NULL && Pkey != NULL && strcmp(di->Pkey, Pkey) == 0)
       : di->Ikey == Ikey)) {
#ifdef DICT_DEBUG
    if (echo) printf("found it\n");
#endif
    return di;
  } else {
    freeitem = NULL;
  }

  for (perturb = hash; ; perturb >>= PERTURB_SHIFT)
  {
    idx = (int)((idx << 2) + idx + perturb + 1);
    di = &d->array[idx & d->mask];
#ifdef DICT_DEBUG
    if (echo)
      printf("idx = %d, flags = %d\n", idx, di->flags);
#endif
    if (di->flags == 0)
      return freeitem == NULL ? di : freeitem;
    if (di->hash == hash
            && di->flags != CDI_FLAG_DEL
            && (d->usePkey
                 ? (di->Pkey != NULL && Pkey != NULL
                                               && strcmp(di->Pkey, Pkey) == 0)
                 : di->Ikey == Ikey))
      return di;
    if (di->flags == CDI_FLAG_DEL && freeitem == NULL)
      freeitem = di;
  }
}

void ZDictResize(CDictHead *d, int minitems) {
  CDictItem  temparray[HT_INIT_SIZE];
  CDictItem  *oldarray, *newarray;
  CDictItem  *olditem, *newitem;
  int        newi;
  int        todo;
  Zhashtype  oldsize, newsize;
  Zhashtype  minsize;
  Zhashtype  newmask;
  Zhashtype  perturb;

  if (d->locked > 0)
    return;

#ifdef DICT_DEBUG
  printf("size: %lu, filled: %lu, used: %lu\n",
           d->mask + 1, d->filled, d->used);
#endif

  if (minitems == 0) {
    if (d->filled < HT_INIT_SIZE - 1 && d->array == d->smallArray) {
#ifdef DICT_DEBUG
      printf("small array not full\n");
#endif
      return;
    }
    oldsize = d->mask + 1;
    if (d->filled * 3 < oldsize * 2 && d->used > oldsize / 5) {
#ifdef DICT_DEBUG
      printf("size OK\n");
#endif
      return;
    }
    if (d->used > 1000)
      minsize = d->used * 2;
    else
      minsize = d->used * 4;
  } else {
    if ((Zhashtype)minitems < d->used)
      minitems = (int)d->used;
    minsize = minitems * 3 / 2;
  }

  newsize = HT_INIT_SIZE;
  while (newsize < minsize) {
    newsize <<= 1;
    if (newsize == 0) {
      /* TODO: throw exception */
      fputs("EXCEPTION: ZDictResize\n", stdout);
      return;
    }
  }

#ifdef DICT_DEBUG
  printf("resizing from %lu to %lu\n", d->mask + 1, newsize);
#endif

  if (newsize == HT_INIT_SIZE) {
    newarray = d->smallArray;
    if (d->array == newarray) {
      memmove(temparray, newarray, sizeof(temparray));
      oldarray = temparray;
    } else
      oldarray = d->array;
    memset(newarray, 0, (size_t)(sizeof(CDictItem) * newsize));
  } else {
    newarray = (CDictItem *)Zalloc((sizeof(CDictItem) * newsize));
    if (newarray == NULL) {
      /* TODO: throw exception */
      fputs("EXCEPTION: ZDictResize\n", stdout);
      return;
    }
    oldarray = d->array;
  }

  newmask = newsize - 1;
  todo = (int)d->used;
  for (olditem = oldarray; todo > 0; ++olditem)
    if (olditem->flags & CDI_FLAG_USED) {
      newi = (int)(olditem->hash & newmask);
      newitem = &newarray[newi];
      if (newitem->flags != 0)
        for (perturb = olditem->hash; ; perturb >>= PERTURB_SHIFT) {
          newi = (int)((newi << 2) + newi + perturb + 1);
          newitem = &newarray[newi & newmask];
          if (newitem->flags == 0)
            break;
        }
      *newitem = *olditem;
      --todo;
    }

  if (d->array != d->smallArray)
      free(d->array);
  d->array = newarray;
  d->mask = newmask;
  d->filled = d->used;
}

/* "ow" is the overwrite flag.  When zero it's not allowed to overwrite an
existing entry. */
CDictHead *ZDictAdd(int ow, CDictHead *d, Zint Ikey, void *Pkey, Zint Ivalue, void *Pvalue) {
  Zhashtype  hash = ZDictHash(d, Ikey, Pkey);
  CDictItem  *di = ZDictLookup(d, Ikey, Pkey, hash);
#ifdef DICT_DEBUG
  if (d->usePkey)
    printf("Adding item %s\n", (char *)Pkey);
  else
    printf("Adding item %lld\n", Ikey);
  if (Pkey != NULL
      && (strcmp(Pkey, "ENUM") == 0
          || strcmp(Pkey, "EQUAL") == 0
          || strcmp(Pkey, "EXIT") == 0))
    dumpdict(d);
#endif
  if (di->flags == 0 || di->flags == CDI_FLAG_DEL || ow) {
    if (di->flags == 0 || di->flags == CDI_FLAG_DEL) {
      ++d->used;
      if (di->flags == 0)
        ++d->filled;
    }
    di->hash = hash;
    if (d->usePkey)
      di->Pkey = Pkey;
    else
      di->Ikey = Ikey;
    di->flags = CDI_FLAG_USED;

    if (Pvalue == NULL) {
      di->Ival = Ivalue;
      di->flags &= ~CDI_FLAG_PVAL;
    } else {
      di->Pval = Pvalue;
      di->flags |= CDI_FLAG_PVAL;
    }

    ZDictResize(d, 0);
  } else {
    /* TODO: throw exception? */
    if (d->usePkey)
      printf("EXCEPTION: ZDictAdd for %s\n", (char *)Pkey);
    else
      printf("EXCEPTION: ZDictAdd for %lld\n", Ikey);
  }
  return d;
}

#ifdef DICT_DEBUG
dumpdict(CDictHead *d)
{
  int        todo = (int)d->used;
  CDictItem  *item;
  int        idx = 0;

  for (item = d->array; todo > 0; ++item) {
    if (item->flags & CDI_FLAG_USED) {
      printf("%2d: %s\n", idx, (char *)item->Pkey);
      --todo;
    } else if (item->flags == 0) {
      printf("%2d: unused\n", idx);
    } else if (item->flags == CDI_FLAG_DEL) {
      printf("%2d: deleted\n", idx);
    } else {
      printf("%2d: invalid flags: %d\n", idx, item->flags);
    }
    ++idx;
  }
}
#endif

''')
    }

    IF useZDictFind
      fd.write('''
CDictItem *ZDictFind(CDictHead *d, Zint Ikey, void *Pkey) {
  Zhashtype  hash = ZDictHash(d, Ikey, Pkey);
  CDictItem  *di = ZDictLookup(d, Ikey, Pkey, hash);
  if (di->flags & CDI_FLAG_USED)
    return di;
  return NULL;
}
''')
    }

    IF useZDictGetPtr
      fd.write('''
void *ZDictGetPtr(CDictHead *d, Zint Ikey, void *Pkey) {
  CDictItem *di = ZDictFind(d, Ikey, Pkey);
  if (di != NULL)
    return di->Pval;
  fputs("EXCEPTION: ZDictGetPtr\n", stdout);
  return NULL;  /* TODO: throw exception */
}
''')
    }
    IF useZDictGetPtrDef
      fd.write('''
void *ZDictGetPtrDef(CDictHead *d, Zint Ikey, void *Pkey, void *def) {
  CDictItem *di = ZDictFind(d, Ikey, Pkey);
  if (di != NULL)
    return di->Pval;
  return def;
}
''')
    }

    IF useZDictGetInt
      fd.write('''
Zint ZDictGetInt(CDictHead *d, Zint Ikey, void *Pkey) {
  CDictItem *di = ZDictFind(d, Ikey, Pkey);
  if (di != NULL)
    return di->Ival;
  fputs("EXCEPTION: ZDictGetInt\n", stdout);
  return 0;  /* TODO: throw exception */
}
''')
    }
    IF useZDictGetIntDef
      fd.write('''
Zint ZDictGetIntDef(CDictHead *d, Zint Ikey, void *Pkey, Zint def) {
  CDictItem *di = ZDictFind(d, Ikey, Pkey);
  if (di != NULL)
    return di->Ival;
  return def;
}
''')
    }

    IF useZDictHas
      fd.write('''
Zbool ZDictHas(CDictHead *d, Zint Ikey, void *Pkey) {
  return (ZDictFind(d, Ikey, Pkey) != NULL);
}
''')
    }

    IF useZDictRemove
      fd.write('''
CDictHead *ZDictRemove(CDictHead *d, Zint Ikey, void *Pkey) {
  CDictItem *di = ZDictFind(d, Ikey, Pkey);
  if (di != NULL) {
    di->flags = CDI_FLAG_DEL;
    --d->used;
    ZDictResize(d, 0);
  } else {
    /* TODO: throw exception? */
    fputs("EXCEPTION: ZDictRemove\n", stdout);
  }
  return d;
}

''')
    }

    IF useZDictToString
      # TODO: when not a string, invoke toString() on the key and value
      fd.write('''
void *ZDictToString(CDictHead *d) {
  garray_T *ga = Zalloc(sizeof(garray_T));
  int hash;
  int first = 1;
  int todo;
  CDictItem *di;
  ga_append(ga, "{");
  todo = d->used;
  for (di = d->array; todo > 0; ++di) {
    if (di->flags & CDI_FLAG_USED) {
      --todo;
      if (first == 0) ga_append(ga, ", "); else first = 0;
      if (d->usePkey) {
        ga_append(ga, "\"");
        ga_append(ga, di->Pkey);
        ga_append(ga, "\"");
      } else
        ga_append(ga, Zint2string(di->Ikey));
      ga_append(ga, " : ");
      if (di->flags & CDI_FLAG_PVAL) {
        ga_append(ga, "\"");
        ga_append(ga, di->Pval);
        ga_append(ga, "\"");
      } else
        ga_append(ga, Zint2string(di->Ival));
    }
  }
  ga_append(ga, "}");
  return ga->data;
}
''')
    }

    IF useZDictKeys
      fd.write('''
CListHead *ZDictKeys(CDictHead *d) {
  CListHead *l = Zalloc(sizeof(CListHead));
  int hash;
  int first = 1;
  int todo;
  CDictItem *di;
  todo = d->used;
  for (di = d->array; todo > 0; ++di) {
    if (di->flags & CDI_FLAG_USED) {
      --todo;
      if (d->usePkey)
        ZListAdd(l, -1, 0, di->Pkey, 1);
      else
        ZListAdd(l, -1, di->Ikey, NULL, 0);
    }
  }
  return l;
}
''')
    }

    IF useZDictClear
      # TODO: free the items
      fd.write('''
CDictHead *ZDictClear(CDictHead *d) {
  if (d->array != d->smallArray)
    free(d->array);
  memset(d, 0, sizeof(CDictHead));
  d->array = d->smallArray;
  d->mask = HT_INIT_SIZE - 1;
  return d;
}
''')
    }

    IF useZDictCopy
      fd.write('''
CDictHead *ZDictCopy(CDictHead *d) {
  CDictItem *di;
  CDictHead *newd = malloc(sizeof(CDictHead));
  memcpy(newd, d, sizeof(CDictHead));
  if (d->array != d->smallArray) {
    size_t len = (d->mask + 1) * sizeof(CDictItem);
    newd->array = malloc(len);
    memcpy(newd->array, d->array, len);
  }
  return newd;
}
''')

# Not used yet:
# void ZDictLock(CDictHead *d) {
#   ++d->locked;
# }
# void ZDictUnlock(CDictHead *d) {
#   --d->locked;
#   ZDictResize(d, 0);
# }
    }

  }
}
