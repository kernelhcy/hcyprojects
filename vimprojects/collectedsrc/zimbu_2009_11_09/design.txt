The Zimbu programming language

  usage.txt  - how to use the program
  syntax.txt - Zimbu syntax
  design.txt - decisions made when creating the language (this file)
  classes.txt - design of classes, interfaces and parts
 
Website: http://www.zimbu.org
        http://sites.google.com/site/zimbuweb/Home


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

YIN AND YANG: DESIGN DILEMMAS

These are issues where there is no clear choice, but we need to find a balance
between two conflicting viewpoints.


A: There is only one way to specify something.
B: Be flexible, give choides to the programmer.

+A: When every Zimbu program uses the same style and conventions, it will be
    much easier to read and understand a program.

+A: Less choices means less time spend on making them.

+B: Everybody has their preferences and should be allowed to make things look
    the way he likes.


-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-


Choices for language constructions
----------------------------------

LINE CONTINUATION: what if a statement doesn't fit in a line.

1. with a backslash at the end (Makefile, macros in C)
                var \
                  = \
                  this + that
        + common mechanism
        - sorting lines requires \ to be moved
        - it's easy to forget the \, because it's at the end of the line

2. backslash at start of the line (Vim script)
                var
                  \ =
                  \ this + that
        + easier to spot than backslash after the line
        + sorting lines works, except for first one
        - uncommon

3. use a semicolon after each statement.
                var
                   =
                   this + that;
        + simple
        + formatting text is simple
        - omitting the semicolon may lead to mistakes.

4. use nothing, 
                var
                   =
                   this + that
        + simple
        + formatting text is simple
        + no need to remember adding the semicolon
        - restricts syntax
        - strange warnings?
        o can add () when needed:
                    var = (this + that)

5. Use nothing like 4., but also use a semicolon as a line separator to put
   statements in one line:
                CASE 5
                        month = "May"
                        days = 31
                CASE 6
                        month = "June"
                        days = 30

       can be written as:

                CASE 5; month = "May"; days = 31
                CASE 6; month = "June"; days = 30

Choice: 5 



ISOLATING CONDITION: find the end of a condition, start of a statement

1. Use () like C
                while (cond)
                  do something
                }
                do
                  something
                until (cond)
                if (con
                        dition)
                   do this
                elseif (cond)
                   do that
                }
        + common
        - two extra symbols needed, the ( actually is superfluous.
        - it's easy to mismatch (), missing ) causes following statement to be
          joined in
        - looks like a function call

2. Use : like Python
                while cond:
                  do something
                }
                do
                  something
                until cond:
                if con
                        dition:
                   do this
                elseif cond:
                   do that
                }
        + only one symbol needed
        - it's easy to forget the :

3. Use { like Python uses :
                while cond {
                  do something
                }
                do
                  something
                until cond {
                if con
                        dition {
                   do this
                elseif cond {
                   do that
                }
        + only one symbol needed
        + looks more like what programmers are used to
        - it's easy to forget the {
        - the until and elseif look ugly, unbalanced { is not what is expected

3a. Like 3, but use } after "until"
                while cond {
                  do something
                }
                do
                  something
                until cond }
                if con
                        dition {
                   do this
                elseif cond {
                   do that
                }
        + only one symbol needed
        + looks more like what programmers are used to
        - inconsistent
        - it's easy to forget the {
        - the until and elseif look ugly, unbalanced { is not what is expected

3b. Use { } around the block
                while cond {
                  do something
                }
                do {
                  something
                } until cond {}
                if con
                        dition {
                   do this
                } elseif cond {
                   do that
                }
        + only one symbol needed
        + looks more like what programmers are used to
        - it's easy to forget the {
        - the until and elseif look ugly

4. Use ; like Python uses :
                while cond;
                  do something
                }
                do
                  something
                until cond;
                if con
                        dition;
                   do this
                elseif cond;
                   do that
                }
        + only one symbol needed
        + consistent with how statements are terminated
        - it's easy to forget the ;
        - uncommon

5. Use ) like Python uses :
                while cond)
                  do something
                }
                do
                  something
                until cond)
                if con
                        dition)
                   do this
                elseif cond)
                   do that
                }
        + only one symbol needed
        + consistent with how statements are terminated
        - it's easy to forget the )
        - it's easy to mix the ) up with unbalanced ()
        - uncommon

6. Use implicit end of condition, require a line break
                while cond
                  do something
                }
                do
                  something
                until cond
                if con
                        dition
                   do this
                elseif cond
                   do that
                }
        + no symbol needed
        - have to make sure that any start of a statement can't look like the
          continuation of the condition.  This disallows ++ and -- at the
          start of a statement (but that doesn't work anyway).

Choice: 6: 2 is also a good second choice, let's try 6 and see if it works
           confusion in meaning of ; disqualifies 4,
           balancing () disqualifies 1,
           3 has problem with elseif


INCREMENT AND DECREMENT

When supporting ++ and -- both in an expression and in a statement it's not
clear where they are separated without an extra punctuation character.

        a = b
        ++c...
Looks like:
        a = b++
        c...

1. Terminate lines with ;
     + it's what programmers are used to
     - easy to forget
     - code looks less clean

2. Disallow ++ and -- in a statement
        a = b
        c += 1
     - it's used quite often, not nice to make it longer

3. Only allow it after the variable
        a = b
        c++
     + works
     - illogical, since pre-increment is allowed in expressions

4. Allow both, but require a line break
        a = b
        ++c

Choice: 4


ALLOW MULTI-STATEMENT LINES?

1. Yes
                if aa  b = 6 else b = 4 }
        - more difficult to read back
        + less lines needed

2. No
                if aa
                        b = 6
                else
                        b = 4
                }
        + more easy to read back
        - more lines needed

Choice 2: easy to read back is more important



COMMENTS

1. Use /* */ like C
        - Can't contain /* or */.
        - Not compatible with shell

2. Use # like shell scripts
        + Can be used as shell script
        - Can't be used in between statements

3. Use // and /* */ like C++
        - Can't be used as shell script
        - Can't be used in between statements

Choice: 2: Shell script possibility is important for interpreted language,
                comments halfway statements is ugly.


EXAMPLE OF THE RESULT:

        # a comment
        IF aap == boven                         # a comment
                        && pietje > 8
                ++pietje
                jantje = 
                        aap + boven
        ELSEIF aap == boven
                        && jantje < 7
                IF cond
                        --pietje
                }
        ELSE
                error()
        }


Evaluation:
- Nice!


SWITCH

Allow any type in a switch statement where "==" can be used.
When the type is string also allow a pattern, using MATCH:

        SWITCH line
           CASE ""
              RETURN Type.empty
           MATCH "^def"
              RETURN Type.def
           DEFAULT
              RETURN Type.unknown
        }

It's not efficient: every pattern will be matched, first one that matches
wins.


LOOPS:

        WHILE cond
           code
           IF v
              CONTINUE
           }
           IF k
              BREAK
           }
        }

        WHILE/top cond        # give a label to the loop
           code
           WHILE too
              IF cond
                 BREAK/top
              ELSEIF cond
                 CONTINUE/top
              }
           }
        }

        # loop over any iterable type (List, Array, etc)
        FOR var IN iterable
           block
        }
        FOR var IN 1 .. 100  # var = 1, 2, ... , 99, 100
           block
        }
        FOR var IN 100 .. 8  # var = 100, 99, ... 9, 8
           block
        }


The variable of the FOR loop usually is only used for that purpose.  Adding a
separate declaration adds complexity, thus should be avoided.  How to specify
the type?

1. With VAR or a specific type:
        FOR VAR arg IN arglist
        FOR string arg IN arglist
        FOR int arg IN arglist

        - Statement becomes a bit difficult to understand
        - Would very often use "FOR VAR arg"

2. With implied type:
        FOR arg IN arglist

        + much easier to read
        - implied type may cause errors?
        - sometimes "arg" is used after the loop

3. With implied type, unless declared earlier:
        FOR arg IN arglist
        string arg
        FOR arg IN arglist

        + much easier to read
        + allow for implied type and explicit type
        - mistakes with using previously defined "arg" unintentionally?

Choice: 3.


Need some way to loop with a condition at the end:

        DO
           code
        UNTIL cond

Can't use WHILE, it would be ambiguous.


Use "REPEAT" or "FOREVER" instead of "WHILE TRUE" ?

        + a bit shorter
        - another statement that needs to be learned

Choice: REPEAT looks nice


INIT-LOOP-CONTINUE

Also need a way to put code that is executed when doing the next round,
equivalent of C for loop:
        for (int i = first; i < last; next(i)) {
          do(i);
        }
Written in Zimbu as:
        i = first
        WHILE i < last
          do(i)
          next(i)
        }

Problem: CONTINUE doesn't go to next(i), noticable in more complicated C:
        for (i = first; i < last; next(i)) {
          doOne(i);
          if (yes(i))
            continue;
          if (not(i))
            break;
          doTwo(i);
        }

So we basically have a three part loop:

        LOOP_INIT
           init
        LOOP_CONDITION cond
           statements
        LOOP_FINALLY
           statements
        }

What keywords to use?

1. overloading:

        REPEAT
           init
        WHILE cond
           statements
        FINALLY
           statements
        }

   - can't use WHILE in init
   - FINALLY sounds more like it's used after looping is done.

2. Use unique words starting with LOOP

        LOOPINIT
           init
        LOOPWHILE cond
           ...
           CONTINUE  # goes to LOOPTAIL
           ...
        LOOPTAIL
           statements
        }

   + much nicer
   - not really shorter than using WHILE:
        {
           init
           WHILE cond
             ...
             CONTINUE  # goes to WHILETAIL
             ...
           WHILETAIL
              statements
           }
        }

3. The tail part is also useful in other loops, such as FOR.  Let's use
   TAIL, and use GOTAIL to jump there.

        FOR i IN mylist
           ...
           GOTAIL  # goes to TAIL
           ...
        TAIL
           statements
        }

        init
        WHILE cond
           ...
           GOTAIL  # goes to TAIL
           ...
        TAIL
           statements
        }

   + Useful way to implement "for (;;)" loop

Choice: 3

Also use TAIL at the end of a function?  Useful for common code before
returning.

        FUNC int doSomething()
           int result
           ...
           IF somecond
             result = -1
             GOTAIL
           }
           ...
        TAIL
           cleanup()
           RETURN result
        }
           


Used very often:
        WHILE TRUE
           c = getChar()
           IF c == File.eof
             BREAK
           }
           IF c == 0
             CONTINUE
           }
           handle(c)
        }

Should we write it shorter?
        WHILE TRUE
           c = getChar()
           WHEN c == File.eof BREAK
           WHEN c == 0 CONTINUE
           handle(c)
        }

Choice: Stick with the normal IF, it's better to be a bit verbose than to have
two ways to do the same thing, requiring the programmer to make a choice.


Python also has an "else" for loops.  Its statements are executed when break
was used in the loop.  We could do this explicitly:

        WHILE cond
           ...
           BREAK  # goes to BREAKUSED
           ...
        BREAKUSED
           statements
        }

This is only useful when there are several BREAK statements with some common
code to be executed.
All together:

        int loopcount = 0
        WHILE continue(loopcount)
           ...
           BREAK  # goes to BREAKUSED
           ...
           BREAK  # goes to BREAKUSED
           ...
        TAIL
           loopcount++
        BREAKUSED
           IO.writeLine("list corrupted")
        }
        IO.writeLine("looped " .. loopcount .. " times")

   - This doesn't look very useful, while adding keyword BREAKUSED.

When giving the loop a label, it's possible to get the way the loop was exited
later:

        int loopcount = 0
        WHILE/loop continue(loopcount)
          ...
          BREAK
          ...
          BREAK
          ...
        TAIL
          loopcount++
        }
        IF loop.breakUsed
          IO.writeLine("list corrupted")
        ELSE
          IO.writeLine("looped " .. loopcount .. " times")
         }

   + easy to check how loop was exited without special statements.



USE NULL OR NIL

Choice: NIL, it's shorter.



OBJECT EQUALITY

The "==" operator compares values.  When comparing two objects their members
are compared for equal values.
        CLASS Foo
          int x
          string y
        }
        Foo a
        Foo b
        ...
        IF a == b  # equivalent to (a.x == b.x) && (a.y == b.y)

To compare two object references for referring to the same object use IS:

        IF a IS b     # TRUE when a and b refer to the same object
        IF a ISNOT b  # FALSE when a and b refer to the same object

Exception: when left or right side of == is NIL, it works like IS.

A class can overrule the default equality check by defining the EQUAL method:

        CLASS Foo
          string msg
          ...
          EQUAL(Foo other)
            RETURN msg == other.msg
          }

Similarly there is the COMPARE() method, used for sorting and operators like
">" and "<".

Status: "==", "IS" and "EQUAL" are implemented.   COMPARE() isn't.


BOOLEAN EXPRESSIONS

It's very common to check a variable against a few values.  How to do this?

1. The normal way:
        var == val1 || var == val2 || var == val3

2. Use a List with implied type:
        [val1, val2, val3].contains(var)

3. Use a special operator, like Python
        var IN [val1, val2, val3]

Choice: support 1. and 3.


FUNCTION DEFINITIONS

How to recognize a function definition:

1. Like C, using a {} block:

        int add(int a, int b)
        {
          return a + b
        }
     - not consistent with other block constructs
     - more difficult to parse
     + what programmers are used to

2. Use the "FUNC" keyword (or "F" or "FUNCTION")

        FUNC int add(int a, int b)
          return a + b
        }
        FUNC VOID add(int a, int b)
          _a = a + b
        }

     + consistent with all other constructs
     - quite different from C, Java, etc.

3. Use the "FUNC" keyword when a value is returned, "PROC" when not

        FUNC int add(int a, int b)
          return a + b
        }
        PROC add(int a, int b)
          _a = a + b
        }

     + consistent with all other constructs
     + avoids the strange VOID keyword
     - quite different from C, Java, etc.

Choice: 3  looks better overal


VARIABLE DECLARATIONS

Just like functions, a declaration need to be distinguished from other
statements.

1. Use the "VAR" keyword (or "V" or "VARIABLE")

        VAR int add = 4
        VAR Modi.Type add

     + consistent with all other constructs
     - quite different from C, Java, etc.
     - verbose

2. Without the keyword

        int add = 4
        Modi.Type add

     - a bit more difficult to parse
     + what programmers are used to

Choice: 2  Avoiding verbosity is more important


DATA ATTRIBUTES

immutable: cannot be changed

storage: number of 8-bit bytes used to store the data


VISIBILITY and ACCESS

By default variables and functions are visible in the same file.
If you change the type, name or arguments it's easy to find all the code
that needs to be changed.
It doesn't really help to further reduce the visibility.

SHARED: visible in files in the same directory and subdirectories.
This is useful for items used in a package that are not to be used outside of
the package.

PUBLIC: visible everywhere.
Forms the interface of the file and package.  Changing a name, type or
argument has implications outside of the package.

CLASS Name
  PUBLIC string first           # external interface
  PUBLIC string last            # external interface
  SHARED Date   lastUpdate      # used in package
         int    hash            # only for current file
}


How to make an item visible for reading only?

1. Use properties, like C#
   - ugly, need to define get() and omit set() instead of assignment

2. Explicitly set access with properties
   + that's what we mostly need

   Use ".read" and ".write" after PUBLIC and PRIVATE:

        CLASS Name
          PUBLIC.read int _reads   # everybody can read, only this file can write
          PUBLIC.read SHARED.write int _v     # writes only inside the package
        }


HOW TO MAKE AN ITEM VISIBLE FOR TESTING ONLY?

1. Put testing code inside the same file
        - messy

2. Make item visible with comment that it's for testing
        + works
        - can be abused

3. Use SHARED.test and PUBLIC.test.
        + nice

Choice: 3


GET AND SET METHODS

In OO programming it's often recommended to use get and set methods.
This leads to lots of code that looks like this:
        private SomeType someMember
        public setSomeMember(SomeType val) {
          someMember = val;
        }
        public SomeType getSomeMember() {
          return someMember;
        }
Note that "SomeType" is given three times and the member name is given three
times.  This is inefficient.

The original thought behind the get and set methods is that one might want to
change the way the member is stored, add assertions, etc., without changing
the code that uses the object.

A much simpler way is to use SET and GET methods.  At first define the member
publicly accessible:
        CLASS Name
          PUBLIC string name
          ...
        }

Now we decide we want to count the number of times the name is read, and limit
the size to 100 when it's set.  This is how it's done:
        CLASS Name
          PUBLIC.read int readCount
          PUBLIC string name
            GET()
              readCount++
              RETURN name
            }
            SET(string value)
              IF value.SIZE() > 100
                name = value.substring(100)
              ELSE
                name = value
              }
            }
          ...
        }

   + Easy to add an assertion:
        Original:
                int count
        New version:
                int count
                  SET(int n)
                    ASSERT.positive(n)
                    count = n
                  }

   + Also allow setting from a different type:
        string zipcode
          SET(string s)
            zipcode = s
          }
          SET(int n)
            ASSERT.positive(n)
            zipcode = n.toString()
          }

The mechanism can also be used for lazy initialization:

       list<string> names
         GET()
           IF names == NIL
             names = NEW()
           }
           RETURN names
         }


INDEXER ACCESS

C# uses a special mechanism to allow container objects to use the var[i]
access notation.  Do we want that?

1. Yes, use a special mechanism to allow object index access.
        - introduces a new mechanism.

2. No, use an interface
        INTERFACE I.index<T>
           PROC setAt(int i, T value)
           FUNC T getAt(int i)
           FUNC int SIZE()
        }
        CLASS Foo IMPLEMENTS I.index<SomeThing>
           List<SomeThing> values
           PROC setAt(int i, SomeThing value)
              values[i] = value
           }
           FUNC SomeThing getAt(int i)
              RETURN values[i]
           }
           FUNC int SIZE()
              RETURN values.SIZE()
           }
           ...
        }

        + uses existing mechanisms

Choice: 2.


ITERATOR

Any class should be usable in a "FOR v IN expr".  This can best be defined
with an interface:
        INTERFACE I.itererable<T>
           FUNC I.iter<T> newIter()
        }
        INTERFACE I.iter<T>
           FUNC bool hasNext()
           FUNC T getNext()
        }
        CLASS Foo IMPLEMENTS I.itererable<SomeThing>
           List<SomeThing> values
           FUNC I.iter<SomeThing> newIter()
             RETURN FooIter.NEW(values)
           }
        CLASS FooIter IMPLEMENTS I.iter<SomeThing>
           List<SomeThing> _values
           int             index = -1
           NEW(List<SomeThing> values)
             _values = values
           }
           FUNC bool hasNext()
              RETURN index + 1 < _values.SIZE()
           }
           FUNC SomeThing getNext()
              index++
              RETURN _values[index]
           }
           ...
        }

This allows having two iterators over the same container.  If this is not
needed the class can implement both I.itererable and I.iter:
        CLASS Foo IMPLEMENTS I.itererable<SomeThing>, I.iter<SomeThing>
           List<SomeThing> values
           int             index
           FUNC I.iter<SomeThing> newIter()
             index = -1
             RETURN THIS
           }
           FUNC bool hasNext()
              RETURN index + 1 < values.SIZE()
           }
           FUNC SomeThing getNext()
              index++
              RETURN values[index]
           }
           ...
        }

NOTE: in reality a List iterator should handle deleting items before the
current position without moving the position.

TODO: an iterator where it's possible to change the value, e.g., when looping
through a list one can change the list item.  Use it like this:

        VAR myList = ["bah", "boo", "beh"]
        FOR &arg IN myList
          IF arg == "boo"
            arg = "boo!"
          }
        }


PREDEFINED METHODS

NEW() - see elsewhere

Use ".SIZE()" on just about everything:

        int n.SIZE()     # number of bytes in an int
        string s.SIZE()  # number of characters (not bytes!) in string s
        List l.SIZE()    # number of items in List l

".EMPTY()"  is equivalent of ".SIZE() == 0" (but may be implemented more
efficiently).  If the class doesn't define EMPTY() this is done automatically.

".EQUAL()" defined by class to check if it's equal to another object of the
same class (the default is to compare all member vars):

        CLASS Foo
          int x
          string y

          FUNC bool EQUAL(Foo other)
            RETURN other.x == x && other.y.foldCase() == y.foldCase()
          }
        }

".COMPARE()" returns -1, 0, 1 for <=, ==, >, etc.
        CLASS Foo
          int x
          string y

          # Ignore case for "y"
          FUNC int COMPARE(Foo other)
            int r = x.COMPARE(other.x)
            IF r == 0
              r = y.foldCase().COMPARE(other.y.foldCase())
            }
            RETURN r
          }
        }

".TYPE()" returns "type" object with members:
        string toString()            string representation
        string toString(int depth)   string representation, recursive
        typeEnum type()              "int", "string", "list", "func", "ref"
        string name()                "int", "string", "list", "func", "ref"
        list<type> members()         members (for a class and object)

        typeEnum
          int
          class
          func
          ref
          etc..
        }

        TODO: should we use classType, intType, funcType, etc?


ARGUMENT BOUNDARY CHECKS

Use the CHECK module:

        CHECK.notNull(var)
        CHECK.notEmpty(string)
        CHECK.positive(number)
        CHECK.true(var != x)
        CHECK.range(number, min, max)

Throws an E.check exception.


OBJECT STORAGE

Always using allocated memory for objects is inefficient.
Objects on the stack are helpful, but cause a allocated/free problem.
1. Use counter to keep track of whether an object is still in use when a
   function returns, move it to allocated memory if it is.  How to fix pointers
   then?
2. Every invoked function has an attribute about whether passed arguments are
   stored or not.  If they are then the compiler puts the object in allocated
   memory.  Example:
        {
          obj = somefunc()
          print(obj)              # obj not stored
        }

        {
          obj = new_obj()
          add_to_list(list, obj)  # obj stored
        }

Objects are allocated with all numeric values set to zero, references set to
NIL and bool set to FALSE.

NIL: no value, not set


MEMORY MANAGEMENT

How to keep track of allocated memory and when it can be freed?

1. Garbage collection (like Java)
     - unpredictable when it happens
     - unpredictable how much memory is in use
     + efficient

2. Reference counting (like Python)
     + predictable
     - inefficient with multi-threading, requires global lock
        
3. Mix
     How?


DATA TYPE DECLARATIONS, TYPE CHECKING

Are variable and function argument types to be declared?

        ++ Compile time checking is needed for reliability.
        -  Need declarations, code can get messy

Choice: Yes.  Reliability is most important.
        Also allow "ANY" type for when a declaration is not wanted.
        Also allow "VAR" type for when the type can be deducted from the
        context.

Alternative: Boo leaves out the declaration.  But this creates another choice
to make, most declarations can either declared explicitly or inferred.  This
can easily create mistakes when a name is mistyped:
                al = 4
                IF cond
                  a1 = 5   # no error, declares new variable
                }

How to do declarations: Mostly like Java.

       List<string> words  # list containing words
       words.add("yes").add("no")

       List<ANY> some
       some.add(1.0).add("dollars").add([1, 2])

       List<Tuple<string, string, int>>  entries
       entries.add(Tuple("John", "Doe", 24))

Status: container types not implemented yet
Status: ANY not implemented yet


Avoid many declarations by using their first assignment:

        VAR foo = getFoo()
        VAR list = [1, 2, 3, 4]
        VAR dict = {'a': 1, 'b': 2}
        VAR x            # type yet unknown
          IF blah
             x = "foo"    # sets the type
          ELSE
             x = "bar"    # much match type of first assignment
          }

Type of "getFoo()" must be known by the compiler its type will be used for
"foo".

Using VAR and NEW() there are two short ways to declare a variable:
          Token t = Token.NEW()  # verbose way 
          VAR t = Token.NEW()    # type comes from assignment
          Token t = NEW()        # destination type used for NEW()
Do we care?

Status: VAR is implemented, not tested much


TYPE CASTS

Here and there we need to explicitly cast one type to another.  E.g. to
convert an int to a float to have a "1 / 2" result in 0.5 instead of 0.

1.  Like C and Java
        (List<float>)some.get() / 2

        o works

2.  Different
        <List<float>>some.get() / 2
        <List<float>>(some.get()) / 2   # parens are optional

        + <> is usually put around the type
        o any parsing conflicts?

3.  Like C++, but always check the type
        CAST<List<float>>(some.get()) / 2

        + easier to see what is being cast 
        + <> is usually put around the type
        - verbose

4.  make it look like a function call
        some.get().CAST(List<float>) / 2

        + looks more like other operations
        - verbose

5.  Different
        List<float>(some.get()) / 2

        + easier to see what is being cast 
        -- looks like like a function call, does not work when function name
           equals a predefined type name.

6.  Different
        float{some.get()} / 2

        + easier to see what is being cast 
        - when editing the expression } needs to be moved

7.  Different
        float<some.get()> / 2

        - <> is usually put around the type, looks strange

Choice: 2.


CONSTRUCTORS

1. Like Java: always need to explicitly create the object.

2. Like C++: implicit constructor.
        - side effects are very hard to control

3. Automatic constructor: Space reserved at compile time for simple types
   (e.g. string).  Otherwise object is constructed at first use (where we
   would crash otherwise).
        
        + Avoids Null pointer exceptions.
        - Need null pointer checks all over the place.
        - Cannot do "IF name == NIL" checks.

Choice: 1  And make the compiler warn for possibly using a NIL.


DEFINING CONSTRUCTORS

1. like Java: use the name of the class
        CLASS ClassName
          ClassName(Type _arg)
            arg = _arg
          }
        }

        - have to repeat the class name
        - have to change the method name when the class name changes

2. use NEW
        CLASS ClassName
          NEW(Type _arg)
            arg = _arg
          }
        }

        + clearly separate from other methods

Choice: 2  shorter is better


INVOKING CONSTRUCTORS

1. like Java:
        ClassName obj = NEW ClassName(args)
        func(NEW ClassName(args))

        - inconsistent use of keyword
        - class name can often be derived from context

2. Use NEW plus class name:
        ClassName obj = ClassName.NEW(args)
        func(ClassName.NEW(args))

        + consistent with class and module calls
        - class name can often be derived from context

3. just use class name:
        ClassName obj = ClassName(args)
        func(ClassName(args))

        - No similarity with constructor definition
        - class name can often be derived from context

4. imply class from destination:
        ClassName obj = NEW(args)
        func(NEW(args))

        - does not work when class cannot be derived form context

Choice: 2 and 4.  offer both verbose and short version


AUTOMATIC CONSTRUCTION

When an object is declared, is it automatically constructed or does it start
with a NIL reference?

1. Always construct an object.  Let the optimizer remove the code when it's
   not needed.  Like in C++.

        FooBar  f           # will work like f = NEW()
        f.doit()            # works
        FooBar  b = NIL     # avoids the construction

        + avoids NIL references
        - fails unexpectedly when there is no constructor without arguments
        - construction of object members may have side effect

2. No automatic construction, reference starts with NIL value.  Like in Java.

        FooBar  f    # will work like f = NIL
        f.doit()     # crash!

        + straightforward
        - more problems with NIL pointers

Choice: 2.  NIL pointers can happen anyway, it's more important to keep it
            consistent: all variables start with zero or NIL value.


FUNCTION ARGUMENTS: BY VALUE OR REFERENCE

Pass by value or pass by reference?
Normally an argument is passed by value.  For objects the value is a reference
to the object, so changes to the argument are changes to the original object:

         PROC inc(Node n)
           n.count++
         }
         Node n
         n.count = 3
         inc(n)
         IO.write(n)  # gives 4

Since passing by value can be confusing (many beginning Java programmers make
mistakes), disallow changing the argument.  This won't compile:
          PROC advance(Node n)
            n = n.next     # ERROR: Can't change argument "n"
          }

Sometimes it's useful to pass by reference, how to do that?

1. Don't support it, force using another solution:
       passing a container object:
         PROC advance(Node[] nl)
           nl[0] = nl[0].next                         # array dereference
         }
         Node theListBeingUsed
         advance([theListBeingUsed])                   # inefficient, strange
       using return value:
         FUNC Node advance(Node l)
           return l.next
         }
         Node theListBeingUsed
         theListBeingUsed = advance(theListBeingUsed)  # name appears twice

     + avoids another mechanism
     - clumsy and verbose

2. Use references:
         PROC advance(Node &l)
           l = l.next
         }
         Node l
         advance(&l)

     + effective
     + explicit about what the intention is
     o an extra mechanism, but still easy to understand

Choice: 2  shorter/simpler method invocation is more important


FUNCTION ARGUMENTS: COMMAS

Allow comma after last func argument?
	func(one,
	     two,
	     three,
	    )

        + easier to move arguments around
        - looks like an error that may go unnoticed, since adding an argument
          may result in using another method.
        - maybe we want to support empty arguments later (like Python)

Choice: Don't allow it

Can we leave out commas in function argument list?
	func(one two three)

        - more difficult to parse, both for humans and compilers
        + less typing

Choice: require commas


POLYMORPHISM

Can a function appear more than once with a different signature for arguments?
For example, a method that can take a string, an int or both.
        doIt("once")
        doIt(111)
        doIt("twice", 222)

1. Yes, like Java:

        PROC doIt(string s)
           doIt(s, 999)
        }
        PROC doIt(int n)
           doIt("none", n)
        }
        PROC doIt(string s, int n)
           name = s
           nr = n
        }

        - Several closely related functions
        - Can't have two with the same signature
        + simple
        o To avoid scattering can require they are all put together

2. No, only one type for each argument, use ANY where needed, use optional
   arguments.

        PROC doIt(ANY x, int n = 999)
          IF x ISA string
             name = x
             nr = n
          ELSEIF x ISA int
             name = "none"
             nr = x
          ELSE
             ERROR
          }
        }

        - Too many "IF"
        - No compile time error for mistakes

3. Allow multiple types for an argument and optional arguments:

        PROC doIt((string, int) x, int n = 999)
          IF x ISA string
             name = x
             nr = n
          ELSE
             name = "none"
             nr = x
          }
        }

        o Still a few "IF"

4. Use optional arguments:

        PROC doIt(string x = "none", int n = 999)
          name = x
          nr = n
        }

        - Can't specify at least one argument is required

5. Do multiple signatures at once:

        PROC doIt(string s) (int n) (string s1, int n1)
          IF s.DEF
             name = s
             nr = 999
          ELSEIF n.DEF
             name = "none"
             nr = n
          ELSE
             name = s1
             nr = n1
          }
        }

        - too many IF

6. Require different method names

        PROC doItString(string s)
           doIt(s, 999)
        }
        PROC doItInt(int n)
           doIt("none", n)
        }
        PROC doIt(string s, int n)
           name = s
           nr = n
        }

        - Several closely related functions, but with different names
        - Cannot require they are all put together
        + simple

Choice: 1.  Avoiding IFs is more useful than the rest.
            4. is also possible.


OPTIONAL FUNCTION ARGUMENTS

Having to specify a separate function for every possible way arguments can be
used is tedius.

1. Don't allow optional function arguments
                PROC addEntry(string name)
                  addEntry(name, 0, Type.nop)
                }
                PROC addEntry(string name, int val)
                  addEntry(name, val, Type.nop)
                }
                PROC addEntry(string name, Type type)
                  addEntry(name, 0, type)
                }
                PROC addEntry(string name, int val, Type type)
                  ...
                }
                addEntry("foo")
                addEntry("foo", 99, Type.foo)
                addEntry("foo", 77)
                addEntry("bar", Type.bar)
                addEntry("xyz", -1, Type.xyz)  # cannot change order

        + simple
        - need to define multiple functions to get the effect
        - inefficient when implemented as-is

2. Optional arguments, like Python:
                PROC addEntry(string name, int val = 0, Type type = Type.nop)
                  ...
                }
                addEntry("foo")
                addEntry("foo", 77)
                addEntry("foo", Type.foo)
                addEntry("foo", 77, Type.foo)
                addEntry("bar", type = Type.bar)
                addEntry("xyz", type = Type.xyz, val = -1)

        + define one function instead of four
        + default values are automatically in one place
        + when an existing function is extended, it's very convenient to add
          an optional argument.
        - changing order of arguments is not very useful
        o becomes confusing with polymorphism?
        - can be confusing when implementing an interface
        - the value can be a complex expression, this offers ways to make ugly
          code

Choice: 2.  Having it all in one place is better.
            But remove it when it tuns out to be ugly


VARIABLE NUMBER OF FUNCTION ARGUMENTS

1. Only allow fixed arguments and variable arguments (varargs) like Java:
                FUNC string format(string format, ANY ... args)
                  # Use args as an Array
                }
                format("Hello %s/%d!", "world", 3)

        + looks good

        Additionally, could provide a function for static type checking.

        Instead of list of arguments can also pass an array, so that this
        is possible:
                PROC writeFormat(string format, ANY ... args)
                  write(string.format(format, args))
                }

2. Require using a List:
                FUNC string format(string format, List<ANY> args)
                }
                format("Hello %s!", ["world"])
        - more special characters
        - function could modify the list (accidentally)
        - no difference with actually passing a list argument
        - only positional arguments, not by name

Choice: 1.
Status: not implemented


SPECIAL CHARACTERS IN STRINGS

Do it like Vim:
        "" strings have \n, \r, \e, etc.
        '' strings are literal.  Double ' to get one.

Also multi-line strings, like in Python:
        """-""" strings with \r \e etc.
        '''-''' strings are literal


LONG STRINGS

A string continues in the next line if the next line starts with a string:

        s = 'first '                # comment
                + 'second'

This does NOT work:
        s = 'first ' 'second'   # error!
Should be:
        s = 'first ' + 'second'

Rationale: Avoid mistakes with quotes embedded in strings.


SLICE INDICES

Is the second index inclusive or exclusive?
Python does it exclusive.  Unfortunately it means you can't get the last byte
of a string:
        "123".slice(-1, -1) == ""
        "123".slice(-2, -1) == "2"

You could use a large number or MAX for the second one:
        "123".slice(-1, MAX) == "3"

When using the index inclusive it's easier:
        "123".slice(-1, -1) == "3"

This gets the slice in characters.  To get the slice as bytes:
        "123".byteSlice(-1, -1)


EXCEPTIONS

Mostly like Python.  Exception is an object with this interface:
        .message
        .stack
The module containing the predefined exceptions is "E".  The names are similar
to Java, but lack the long word "Exception":
        E.outOfMemory
        E.nullPointer

        TRY
          code
          f = File.fileReader(name)
          code
        CATCH E.outOfMemory, E.nullPointer e
          IO.write(e.message)
        FINALLY
          f.close()
        }

IMPORT

System functions are available without any imports.  Other things can be
imported:

        IMPORT "some/dir/parser.zu"
        VAR p = Parser.new()

The file can define a module and/or class.  They appear in the namespace.
The file cannot define global variables or functions.  All items in the
imported file must be part of a module or class.

The directory and file name characters must be valid on all systems:
    - letters and numbers (also multi-byte)
    - one of: '_', '-'
    - space

There is a default path where to look for imports:
        1. relative to directory of input file
        2. library path, e.g. "/usr/local/zimbu/lib"
        3. path defined in build file

Implementation: each import only needs to be read and parsed once.


WHERE TO PUT IMPORTS

1. Always at the start of the file, before any other statements
   + clear, simple
   - can't put imports just before where they are used

2. Anywhere
   + flexible
   - harder to see what the dependencies are

Choice: 1.  In practice this works better


VISIBILITY OF IMPORTS

1. When a file is imported, all files imported by that file are used as well
   + any dependent classes and types will be automatically declared
   - may cause unexpected name clashes, as the first import may not be able to
     tell the other files what they can import

2. When a file is imported, only the items defined by it are used.
   + no name clashes
   - When other types are needed, e.g., returned by a function, this requires
     more imports.

Choice 2.  Avoiding unexpected name clashes is more important.


SYNTAX OF IMPORTS

1. No quotes
        IMPORT name
   + simple
   - can't have special things

2. String
        IMPORT "this dir/file.zu"
   + can have spaces inside

3. Expression
         IMPORT rootDir + "subdir/file.zu"
   + shorter when lots of imports below one dir
   - difficult for tools to find out where files are

4. Mix
        Import libraries with a simple name
                IMPORT url
                IMPORT testing/assert
        Import local files with double quotes
                IMPORT "util/parse.zu"
        Import special files with full name
                IMPORT <images/pdf.png> AS pdfImage

Choice: 4


PATH OF IMPORTS

1. Only relative paths, use search path to find them
          IMPORT google/util/string.zu  # library stuff
          IMPORT fancyfile.zu           # program stuff
   - not always clear where file should be found

2. Explicitly use search path to find them
          IMPORTLIB  google/util/string.zu   # library stuff
          IMPORT fancyfile.zu                # program stuff
   + no unexpected name clashes with some lib path

3. Use search path and allow absolute dir
          IMPORTLIB google/util/string.zu   # library stuff
          IMPORT ~/mylib/fancyfile.zu       # program stuff
   + no unexpected name clashes with some lib path
   + don't need to set path when building

4. Like C: "file" for direct, <file> for using lib search path.
          IMPORT <google/util/string.zu>    # library stuff
          IMPORT "fancyfile.zu"             # program stuff
          IMPORT "~/mylib/fancyfile.zu"     # program stuff
   + no unexpected name clashes with some lib path
   + don't need to set path when building

Choice: 4.  A name without "" or <> is handled like <.zu>:
                IMPORT url
            equivalent to:
                IMPORT <url.zu>


SCOPE OF SYMBOLS DEFINED IN IMPORT

When imported file A imports file B, are the symbols from B visible in the
current scope?

1. No. 
        + Allows symbols from B conflicting with current scope
        - Requires importing B in current scope if symbols in B are used

2. Yes
        + Less imports required
        - May lead to unsolvable conflicts of unexpected imports

Choice: 1.  It's more important to keep control over what happens and avoid
            unexpected conflicts than reducing the number fo imports needed.


WHAT CAN BE DEFINED IN AN IMPORT

1. Multiple modules and classes
        + flexible
        - when something is added this may cause unexpected name conflicts in
          other files

2. Only define one Module and/or Class name, like Java
        + clear and simple
        - requires more files

Choice: 2.  Avoiding unexpected name conflicts is very important.


FILE NAME MATCHES MODULE NAME

1. No required relation between module/class name and file name
        + flexible
        - up to the user to use good names

2. Require the file name to start with the class/module name.  Something else
   may follow.  E.g., the Module "Foobar" can be in the file "foobar.zu",
   "foobar_v2.zu", "foobar_alt.zu", but not in "barfoo.zu" or "foobarbar.zu".
   Case is ignored.
        + can see from import statement where items are most likely defined
        - less flexible

3. Require the file name to be exactly the same as the class/module name.
        - No way to make a copy of a class in another file
        - Mistakes in case cause useless problems.

Choice: 2.  Reasonable balance between flexibility and predictability.


IMPORT WITH NAME CONFLICT

It may happen that two imported files define a module or class with the same
name.  E.g., when using two versions of the same file.

1. Use IMPORT - UNDER
        IMPORT "mymodule.zu"
        IMPORT "mymodule_old.zu" UNDER old
        IMPORT "mymodlue_tryout.zu" UNDER try

        VAR x = MyModule.create("foo")
        VAR y = old.MyModule.create("bar")
        VAR z = try.MyModule.create("abc")

2. Use IMPORT - AS
        IMPORT "mymodule.zu"
        IMPORT "mymodule_old.zu" AS MyModuleOld
        IMPORT "mymodule_tryout.zu" AS MyModuleTry

        VAR x = MyModule.create("foo")
        VAR y = MyModuleOld.create("bar")
        VAR z = MyModuleTry.create("abc")

        + Allows using one name instead of a name with dot

Choice: 2.
Status: not implemented


IMPORTING OTHER KINDS OF CODE FILES

For example: protocol buffers (http://code.google.com/apis/protocolbuffers)

1. Require an external tool to convert to a Zimbu file, use the IMPORT command.

        + generic, flexible
        - dependency on external tool

2. Import each type with a specific command:

        IMPORT.proto "api/message.proto"

        + easy build
        + makes it part of the language
        - very specific for one type of file

3. Use Class with specific interface to do the conversion.
        
        IMPORT <proto.zu>
        IMPORT.Proto "api/message.proto"

        + flexible
        - requires building the class before parsing, unclear how
          this would work

4. Use Plugins with specific interface to do the conversion.
        
        PLUGIN Proto <proto.zu>
        IMPORT.Proto "api/message.proto"

        + flexible
        + clearly separates a normal import from using a plugin
        + can compile the plugin separately
        - requires another keyword

Choice: 4.  When proto support is part of the languages it becomes
            IMPORT.PROTO.


IMPORTING ZWT MODULE

The UI of a ZWT application is defined in a separate Zimbu file.  It uses
exactly the same syntax, the only special thing about it is how it's imported:

        IMPORT.ZWT "ui.zu"

This implies that "ui.zu" must be produced as a Javascript file, to be loaded
by a browser.


IMPORTING OTHER KINDS OF FILES

It should be easy to use images and embed them in the program.

        IMPORT "images/docOpen.png" UNDER openImage

This reads the file into a binary object "openImage".  Works for supported
types.

Other types can be used with a plugin:

        PLUGIN Icon <iconreader.zu>
        IMPORT.Icon "icons/slides.ico" UNDER slideIcon


FILTERING

Many simple programs read input and produce output.  E.g. to trim white space,
replace one word for another, etc.

To make this simple we can provide an alternative to MAIN: FILTER

        FILTER
          WHILE !IO.eof()
            IO.write(IO.readLine().substitute(" *$", ""))
          }
        }

Special handling of the arguments:
    prog [-o outfile] [--] [infile]
                -o outfile            output file name
                --                    end of options
                infile                input file name
        read from infile (stdin when omitted)
        write to outfile (stdout when omitted)

    prog --inplace fname
    prog -i fname
        read from fname
        write to tempfile, rename tempfile to fname when done


CODE REFERENCES

It should be possible to pass code to be executed from one place to another.
In C and C++ this would be done with the preprocessor, but that's messy.

Expression:  Evaluates to a value.  No arguments possible.
Procedure:   Code to execute.  Arguments allowed.
Function:    Code to execute, must return a value.  Arguments allowed.

Declarations:
        expr<string>      myExpr
        proc<int>         myProc
        func<string, int> myFunc
        iterator.I        myObject

Values:
        myExpr = {{"date:" + Date.now()}}
        myProc = PROC(int arg)
                   IO.write("count: " + arg)
                 }
        myFunc = FUNC(string, int score)
                   RETURN score > 5 ? "good" : "bad"
                 }
        myObject = OBJECT IMPLEMENTS iterable
                     list<string> counts = ["first", "second", "third"]
                     int idx = 0
                     FUNC bool hasNext()
                       RETURN idx < counts.SIZE()
                     }
                     FUNC string next()
                       RETURN counts[i++]
                     }
                   }

For a closure items from the scope can be passed to the function:

        string msgGood = catalog.get("good")
        string msgBad = catalog.get("bad")
        ProcessScore(text,
                     FUNC<string>(int score).USE(msgGood, msgBad)
                       RETURN score > 5 ? msgGood : msgBad
                     })


CALLBACKS

Especially for asynchronous code we need a way to pass a function or method to
be called back later.

When calling back a function a reference to the function can be used.  This
only requires the arguments to match.  See myproc above.

If there is an additional argument we need something more.  These arguments
are passed from where the callback is created to the function, without the
code invoking the callback knowing about these arguments.

When calling back a method this also requires a reference to the object.
However, the code invoking the callback usually doesn't need to know about the
object, just the arguments for the method.  This is like passing the object as
an argument, but it changes the way the method is invoked.

To be able to pass the callback with the object and/or arguments we need it to
have two interfaces:
1. What the code invoking the callback expects, with the expected number of
   arguments.
2. What the invoked function expects, with zero or more additional arguments
   and/or an object reference.

So a callback is a type that is defined with:

        callback<invoker_interface, invokee_interface>

And you can leave out invokee_interface to get the interface that it extends:

        callback<invoker_interface>

This is used for the function invoking the callback:

        PROC getMonth(callback<string> cb)
          string month = ...
          cb(month)
        }
        ...
        PROC printSome(string lead, string month)
          ...write(lead + ": " + month)
        }
        ...
        callback<proc<string>, printSome.I>

TODO: is Interface2 a superset of Interface1 or only the missing parts?
      A superset is probably simpler, because "func.I" can be used.
          callback<func<int, string, string>, function.I>
      But when not doing it that way types will have to be repeated.  For a
      function the return type comes first, thus it's added after that:
          callback<func<int, string, string>, func<int, int &, string, string>>
      Alternative:
          callback<func<int, [int &], string, string>>
      How to make return type optional?  perhaps list the extra arguments:
          callback<func<int, string, string>, int &>
        so basically:
          callback<Interface, extraArg1, extraArg2>
      However, an object method is different from a function, how to we
      specify a method, it requires an extra object argument.  Perhaps:
          callback<func<int, string, string>, Demo.func<int, string, string>>

E.g.:

        MODULE Gen
          PROC sort(Array[] text, callback<func<int, string, string>> cb)
            ...
              cmp = cb(names[i], names[j])
            ...
          }
        }

        (in another file)

        FUNC int compare(int &count, string left, string right)
          count++
          RETURN left.compare(right)
        }

        string[] names
        int count
        callback<func<int, string, string>, compare.I> cb = NEW(compare)
        cb.setArgs(&count)
        GEN.sort(names, cb)

This gets a bit verbose, so let's generate this stuff automatically:

        Gen.sort(names, CALLBACK(compare, &count))

The CALLBACK uses first argument as a function or method reference.
Further arguments are passed to that function when the callback is invoked.
Further arguments must be given by the code invoking the callback.

When a method is invoked the second argument must be an object of the class.
Very often THIS will be used, as in this example:

        CLASS DemoCallback
          string[] names
          int count

          FUNC int compare(string left, string right)
            count++
            RETURN left.compare(right)
          }

          PROC sort()
            Gen.sort(names, CALLBACK(compare, THIS))
          }
        }


LAZY EVALUATION

In many places you see code like this:

        PROC log(string msg)
           IF logging
             logFile.write(msg)
           }
        }
        ...
        log("foo=" + foo + ", bar=" + bar)

When "logging" is FALSE, the argument gets evaluated but is never used.
That's a waste of time.

1. Lazy as an argument type, like D
        PROC log(LAZY string msg)
        ...

        - At the place where log() is called it's not at all clear that the
          expression won't be evaluated.  That can be unexpected, esp. if the
          expression has side effects.

2. Use an inline function:
        PROC log(FUNC<string>() getMsg)
           IF logging
             logFile.write(getMsg())
           }
        }
        ...
        # TODO: syntax
        log(FUNC()
              RETURN "foo=" + foo + ", bar=" + bar
            })

        - Too verbose.

3. Use the expression type:

        FUNC log(Expr<string> msg)
           IF logging
             logFile.write(msg.eval())
           }
        }
        ...
        log(`"foo=" + foo + ", bar=" + bar`)

        + Nice.

        Implementation: Compile as a function call with "foo" and "bar" as
        arguments.

Choice: 3

This is related to closures, Martin Fowler writes:
        http://www.martinfowler.com/bliki/Closure.html
Essential that a closure can use variables from the scope where it is defined
into the scope where it is executed.


THREADS

Main items:

      THREAD module   base of most things
      thread class    one for every thread
      lock class      generic lock

Run a procedure asynchronously:

        RUN someProc(arg1, arg2)

Same as:
        thread.NEW(NEW callback(someProc, arg1, arg2)).start()

- Name of the thread will be "someProc__N" where N is a number.
- Does not provide an easy way to wait for completion or make any settings.

  THREAD.threads()  list of all existing thread objects
  THREAD.current()  currently active thread
  THREAD.data       dict for thread-local things

  thread t = NEW()
  thread t = NEW(proc)   
  thread t = NEW(callback)   
  t.name     string
  t.state    THREAD.State.new, running, finished
  t.type     THREAD.Type.main, daemon, normal
  t.keep     TRUE to keep thread when finished

  t.kill()       if thread is running, it will stop asap
  t.wait()       blocks until thread is finished
  t.remove()     remove from THREAD.threads() list
  t.setDaemon()  make thread a deamon (can't be undone)

  t.setProc(proc)  proc to invoke when started
  t.setCallback(cb)  callback to invoke when started
  t.run()        overrule to have the thread execute this when started
                 default invokes proc passed by creation or setProc()
  t.start()      prepared the thread and runs t.run() in it

TODO: run() and start() are confusing.  Use other name for run():
        doit()
        impl()
        body()    <-- this one now
        runbody()
        execute()


Threadpool concept: a set of threads that can be used to execute code.
"Async" executes a block of code 

        tp = New Threadpool(8);  # pool with 8 threads
        For i In mylist
          Async tp
            process(i);          # block executed by one of the threads
          }
        }
        tp.Wait();               # wait for all threads to finish


PIPES

In Unix shell we have the concept of a pipe:  "prog1 | prog2".  This is a very
effective way of connecting asynchronous processes.  

In Zimbu the Pipe class is a similar thing, although more flexible.  An
example:

        PROC reader(Pipe<string> s)
          FOR day IN s
            IO.write(day + "\n")
          }
        }

        Pipe<string> s = NEW()
        s.addReader(reader)
        FOR day IN ["Mon", "Tue", "Wed", "Thu", "Fri"]
          s.write(day)
        }
        s.close()

The reader() function will be running in a separate thread, asynchronously.

TODO: syntax of addReader().

It's also possible to set both a reader and writer, and have the main thread
wait for them to finish:

        PROC writer(Pipe<string> s)
          FOR day IN ["Mon", "Tue", "Wed", "Thu", "Fri"]
            s.write(day)
          }
          s.close()
        }

        Pipe<string> s = NEW()
        s.addReader(reader)
        s.addWriter(writer)
        # do something else
        s.wait()

There can be multiple readers and writers.  This parallizes tasks, e.g. for
message handling.  One can also specify that a new reader task is created when
an object is available for reading:

        Pipe<Message> s = NEW()
        s.addWriter(getMessages)
        s.addReaders(reader, 10)  # up to 10 parallel reader threads


ADVANCED FILE ACCESS

Often it is convenient to access data as if it was a file in location in a
file system, even though it's actually accessed with a specific protocol.
For example, accessing files over ftp.

Since the number of protocols is limitless, it needs to be possible to plugin
a module for each.  The interface for the module consists of several parts:
        - Navigation through the file system, checking directory access,
          listing the contents of directories.
        - Renaming directory items, moving directory items, changing access
          permissions, deleting directory items.
        - Creating a file, opening an existing file, reading and writing.

Usage:
        AFile f = AFile.open("ftp", "ftp.vim.org", "/pub/vim/patches")
        IO.write(f.dirList())
        f.cd("..")
        f.open("MIRRORS")
        IO.write(f.read())

"To be continued..."


CONDITIONAL BUILDS

The same source code may be used to build with different features.  And it may
be build for test purposes and profiling.

Using the preprocessor like C and C++ can cause lots of problems, so that
needs to be avoided.

1. Use IF and other conditionals at the toplevel.  Use a BUILD module to
   store settings:

        IF BUILD.has("thread")
          IMPORT <thread>
        }

Choice: TBD


DOCUMENTATION

1. Like Java:
        /**
         * html <tag>text</tag>
         *
         * @param name  text
         * @return  text
         */

        + useful
        - HTML is hard to ready in the source code itself
        - no encouragement to write proper comments

2. Use any comment close to an item as documentation.  Special items:
        @argument@  - refers to an argument name
        @return     - precedes comment about the returned value
        @throws     - comment about when a certain exceptionis thrown
        

        # Sort the list with specified sort order @order@.
        # @return the sorted list.
        # @throws E.NullPointer when there are no items
        FUNC Date sortOn(SortOrder order)
          ...
          RETURN THIS
        }

        + short and simple
        + useful
        - less formatting possible

3. Like 2., but use | instead of @:
        # Sort the list with specified sort order |order|.
        # |return the sorted list.
        # |throws E.NullPointer when there are no items

        + short and simple
        + useful
        + easier to read than with @
        - less formatting possible

Choice: 3.


STARTUP SEQUENCE

Invoking functions from MAIN() to initialize modules has the problem that you
need to know which modules are being used.  It's better when a module can
initialize itself.

This can be a bit tricky, because when a module is initialized it may depend
on another module to already be initialized.  In most cases it works to do the
initialization in any order, and as soon as a module is first used.  

   1. explicit assignments to variables
   2. call INIT1() for each module
	Place to add arguments to ARG.
     	When invoking another module, that INIT1() is called first, unless
	already busy.
	Cannot use threads.
   3. init ARG module
   4. call INIT2() for each module  (can use other modules)
        can do things that depend on other modules to be initialized
	e.g. starting a webserver, starting threads
   5. invoke MAIN()


CONDITIONAL COMPILATION

This parses and resolves all the code, but only produces code for selected
sections:

     GENERATE_IF lang == "C"
       ...
     GENERATE_ELSE
       GENERATE_IF permu == "gecko"
         ...
       GENERATE_ELSEIF permu == "ie5"
         ...
       GENERATE_ELSE
         ...
       }
     }

Supported variables are:
        lang      "C" or "JS"
        permu     Javascript permutation


FAR FUTURE IDEAS

Consider all sides of creating and using computer programs.

- Design with diagrams, sequence tables, etc.
- Presenting the design and progress to the end-user or customer.
- Prototyping
- Developer tools: editors, documentation, debugging, profiling
- Testing and Quality Assurance
- Programming for speed in one part, ease of use in another.


Foundation: Computer programming involves data, instructions and I/O.

Important aspect of data: Life expectancy
- until program ends (variables)
- until uninstall (on harddisk)


Decision localisation: Try to minimize the impact of change of a choice.
The more likely a change is, the more local it should be.


Programming language:
- Concentrate on interfaces, these define the building blocks.  That's more
  important than object orientation.
- Avoid decisions that are not important (e.g., is a square a rectangle or the
  other way around).
- Support for many data structures.
- both
        A) compiled and executed
        B) interpreted, used as a script language


An alternative is to generate byte code.  The .net byte code could be used, as
it supports managed C++.


OPTIMIZATION

Instead of always reading the .zu file, parse it and produce a .c file and a
.zuo file that contains the exported symbols and docs (like a Java .class file
but without the bytecode).


TESTING

When taking testing seriously, there quickly is more testing code than
production code.  Therefore it is important that writing testing code is
just as easy.

There are two main areas:
1. Test the production code (low level, end-to-end, test suites, etc.)
2. Verify the tests find all mistakes.


For the test verification we need to specify in the source code what changes
should trigger one of the tests to fail.  How to do this?

For example, we have this simple condition, making sure "a" is not larger than
"b":

        IF a > b
          a = b
        }

We need to verify that a test breaks if the "a > b" condition was altered:
        a > b + 1
        a + 2 > b
        a >= b  will actually work, so don't test this
        TRUE
        FALSE


1. Use inline annotations:

        IF a > @test(<) b @test(TRUE) @test(FALSE)
          a = b
        }

        - messy

2. Use comment to specify changes, these work like search & replace:

        # @testFail(b, b + 1)
        # @testFail(a, a + 2)
        # @testFail(a > b, TRUE)
        # @testFail(a > b, FALSE)
        IF a > b
          a = b
        }

        o verbose, but works

3. Specify changes elsewhere, add comment with ID

        IF a > b           # @testMark(AgtB)
          a = b
        }

        in test file:
          testChange(Module.AgtB, "b", "b + 1")
          testChange(Module.AgtB, "a", "a + 2")
          testChange(Module.AgtB, "a > b", "TRUE")
          testChange(Module.AgtB, "a > b", "FALSE")

        + less verbose
        + direct connection between intention of a test and source code.
        - dependencies between files


vim: set tw=78 et sw=2 :
