#
# The Zimbu compiler written in Zimbu
#
# Node class and associated things.
#
# Copyright 2009 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT "attr.zu"
IMPORT "conversion.zu"
IMPORT "error.zu"
IMPORT "token.zu"
IMPORT "pos.zu"
IMPORT "scope.zu"
IMPORT "symbol.zu"
IMPORT "usedfile.zu"

CLASS Node
  Type      n_type
  int       n_int
  string    n_string
  int       n_undefined   # number of undefined items at/below this node

  Node      n_returnType  # function return type, type for local FOR var
  Node      n_cond        # condition for "cond ? expr1 : expr2"
  Node      n_left        # main or left part of expression
  Node      n_right       # right part of expression
  Node      n_next        # next node in a sequence

  Conversion n_conversion  # conversion for result of expression
  Symbol    n_ret_class   # class returned by expression

  Pos       n_start       # start in input
  Pos       n_end         # end in input
  Symbol    n_symbol      # Symbol related to this node; set in first pass.
                          # Not used for pass zero.
  Symbol    n_returnSymbol  # passed from resolve to write_c
  Attr      n_attr        # flags: ABSTRACT, VIRTUAL, etc.
  string    n_scopeName   # name used for blocks, set in first pass
  Type      n_nodeType    # for a block: type of the block; for an
                          # expression: resulting type
  UsedFile  n_usedFile    # for import node only

  # construct a Node that only has the type set.
  NEW(Type type)
    n_type = type
  }

  # Return the result type for this node.
  FUNC Type resultType(Scope scope)
    SWITCH n_type
      CASE Type.bool
      CASE Type.status
      CASE Type.int
      CASE Type.string
        RETURN n_type

      CASE Type.id
        RETURN scope.getSymbolType(n_string)

      CASE Type.op_mult
      CASE Type.op_div
      CASE Type.op_rem
      CASE Type.op_minus
        RETURN Type.int

      CASE Type.op_plus
        IF n_left.resultType(scope) == Type.string
            || n_right.resultType(scope) == Type.string
          RETURN Type.string
        }
        RETURN Type.int

      CASE Type.op_equal
      CASE Type.op_notequal
      CASE Type.op_gt
      CASE Type.op_gte
      CASE Type.op_lt
      CASE Type.op_lte
      CASE Type.op_and
      CASE Type.op_or
      CASE Type.op_is
      CASE Type.op_isnot
      CASE Type.op_isa
      CASE Type.op_isnota
        RETURN Type.bool
    }
    RETURN Type.unknown
  }

  # Return the Symbol for the top of "n".
  # Return NIL when we don't end up with a module.
  # Return NIL when the top is not an ID or there are other nodes than
  # "member".
  FUNC Symbol findTopModule(Scope scope)
    Symbol sym
    IF n_type == Type.id
      sym = scope.getSymbol(n_string)
    ELSEIF n_type == Type.member
      sym = n_left.findTopModule(scope)
      IF sym != NIL
        sym = sym.findMember(n_string)
      }
    }
    IF sym == NIL || (sym.type != Type.module && sym.type != Type.lib_module)
      RETURN NIL
    }
    RETURN sym
  }

  # Report an error related to this node.
  PROC error(string msg)
    Error.report(msg, n_start)
  }

  FUNC string toString()
    RETURN toString("", FALSE, FALSE)
  }

  FUNC string typeString()
    RETURN "type: " .. n_type.name() .. "\n"
  }

  FUNC string toString(string indent, bool recurse, bool doNext)
    string s = indent .. typeString()
    IF indent == "" && n_start != NIL
      s ..= "start: " .. n_start.toString() .. "\n"
    }
    IF n_string != NIL
      s ..= indent .. "name: " .. n_string .. "\n"
    }
    IF n_int != 0
      s ..= indent .. "value: " .. n_int .. "\n"
    }
    IF n_undefined != 0
      s ..= indent .. "undefined: " .. n_undefined .. "\n"
    }
    IF n_symbol != NIL
      s ..= indent .. "symbol: " .. n_symbol.toString() .. "\n"
    }
    IF n_conversion != Conversion.none
      s ..= indent .. "conversion: " .. n_conversion.name() .. "\n"
    }
    IF n_left != NIL
      IF recurse
        s ..= indent .. "left:\n" .. n_left.toString(indent .. "|  ",
                                                            recurse, doNext)
      ELSE
        s ..= indent .. "left: " .. n_left.typeString()
      }
    }
    IF n_right != NIL
      IF recurse
        s ..= indent .. "right:\n" .. n_right.toString(indent .. "|  ",
                                                            recurse, doNext)
      ELSE
        s ..= indent .. "right: " .. n_right.typeString()
      }
    }
    IF doNext && n_next != NIL
      RETURN s .. indent .. "next:-------------------------\n"
                                  .. n_next.toString(indent, recurse, doNext)
    }
    RETURN s
  }

  # Check that the name of this node starts with an upper case letter.
  # Used for Class, Enum, Bits, etc.
  PROC checkTypeName(string what)
    IF n_string[0] < 'A' || n_string[0] > 'Z'
      error(what .. " name must start with upper case letter")
    }
  }

  # Check that the name of this node starts with a lower case letter.
  # Used for function, enum value, etc.
  PROC checkItemName(string what)
    IF (n_string[0] < 'a' || n_string[0] > 'z') && n_string[0] != '_'
      error(what .. " name must start with lower case letter or '_'")
    }
  }

  SHARED

    ENUM Type
      unknown
      eof
      nil             # NIL
      this            # THIS
      parent          # PARENT
      id              # identifier (including IO, HTTP, etc.)
      ref             # argument or variable passed by reference

      # basic data types
      int
      nat
      string
      char
      bool
      status
      list
      dict
      dictPair        # first item in {expr:expr}
      array
      any
      var

      # complex data types
      module
      lib_module      # lib module that hasn't been loaded yet
      class
      shared
      interface
      object          # instance of class
      i_object        # instance of an interface, check object type at runtime
      bits_small      # fits in an int
      bits_big        # up to 64 bit
      bits_decl
      enum
      enum_value
      enum_decl
      equal_def       # EQUAL(args) body }
      new_def         # NEW(args) body }
      func_def        # FUNC type name (args) body }
      proc_def        # PROC name (args) body }

      func_ref        # Func<type>(args) name
      proc_ref        # Proc(args) name

      # special items
      import
      main
      copydirect      # >>> # comment
      cfunc

      # Compile time conditionals
      gen_if
      gen_elseif
      gen_else

      # statements
      if
      else
      elseif
      while
      for
      in
      break
      continue
      proceed
      assign
      minassign
      plusassign
      stringassign
      block
      new           # call NEW() or NEW.Type()
      copy          # call COPY()
      size          # call SIZE()
      function      # call function
      switch
      case
      default
      declare
      do
      until
      plusplus
      minmin
      return
      exit

      # operators
      bit_and
      bit_or
      bit_xor
      op_concat
      op_mult
      op_div
      op_rem
      op_plus
      op_minus
      op_negative
      op_tilde
      op_not
      op_pre_incr
      op_pre_decr
      op_post_incr
      op_post_decr
      op_rshift
      op_lshift

      op_equal
      op_notequal
      op_gt
      op_gte
      op_lt
      op_lte
      op_is
      op_isnot
      op_isa
      op_isnota

      op_and       # &&
      op_or        # ||

      op_alt       # expr ? expr : expr
      parens       # ( expr )

      # sequence operators
      member       # a.b
      bits_value   # a=b
      method       # a(x)
      subscript    # [i]
      typespec     # <type, ...>
      op_comma

      # module member with produce method
      lib_method
    }

    # Return the type for a built-in type name.
    FUNC Type name2Type(string name)
      IF name == "string"
        RETURN Type.string
      }
      IF name == "int"
        RETURN Type.int
      }
      IF name == "bool"
        RETURN Type.bool
      }
      IF name == "status"
        RETURN Type.status
      }
      IF name == "list"
        RETURN Type.list
      }
      IF name == "dict"
        RETURN Type.dict
      }
      RETURN Type.unknown
    }

    #
    # Return TRUE if |type| is a pointer type.
    # Note that i_object is not a pointer type.
    #
    FUNC bool isPointerType(Type type)
      SWITCH type
      CASE Type.nil
      CASE Type.class
      CASE Type.object
      CASE Type.i_object
      CASE Type.proc_ref
      CASE Type.func_ref
      CASE Type.string
      CASE Type.list
      CASE Type.dict
        RETURN TRUE
      }
      RETURN FALSE
    }

    FUNC bool isMethodType(Type type)
      RETURN type == Type.lib_method
          || type == Type.proc_def
          || type == Type.func_def
          || type == Type.new_def
          || type == Type.equal_def
    }

    FUNC bool isTypeWithArgs(Type type)
      SWITCH type
        CASE Type.equal_def
        CASE Type.new_def
        CASE Type.proc_def
        CASE Type.func_def
        CASE Type.lib_method
        RETURN TRUE
      }
      RETURN FALSE
    }

  }

}

