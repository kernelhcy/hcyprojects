Example: a GUI list; a List that displays its items.
   this is a mix of a List and a widget

CLASS GuiList IMPLEMENTS List<I_Widget>.I, I_Widget
   INCLUDE List<I_Widget> myList

   # Methods of myList that need to be wrapped
   add -> addAndUpdate
   pop -> popAndUpdate
   remove -> removeAndUpdate

   # Wrapper methods
   FUNC GuiList addAndUpdate(I_Widget item, Int after)
      myList.add(item, after)
      update(after + 1, myList.SIZE())
      RETURN THIS
   }
   FUNC I_Widget popAndUpdate(Int i)
      I_Widget w = myList.pop()
      update(i, myList.SIZE() + 1)
      RETURN w
   }
   ...

   PROC update(Int from, Int to)
     ...
   }
}


TODO:

When members have behavior attached to them (implicit get/set mehods),
these also need to be specified in the interface.
Possible solution: define the members in a Group and use the Group in the
Interface.


INHERITANCE, INTERFACES AND GROUPS
 

Problem: The method signature needs to be defined several times.
Sulution: Groups

A Group defines a group of methods and perhaps variables related to them.
A Group can be used in a Class to include the method signatures and the
implementation.
A Group can be used in an Interface to include the method signatures only.
A Group can have local variables and methods that are not visible in the Class
or Interface it is included in.

        GROUP Address
           String name
           String street
           String city
           FUNC String toHtml()
              RETURN name + "<BR>" + street + "<BR>" + footerHtml()
           }
           EXTERN FUNC String footerHtml()
        }

        CLASS NationalAddress IMPLEMENTS Address.I
           INCLUDE Address
           String zip
           FUNC String footerHtml()
              RETURN zip + " " + city
           }
        }

        CLASS InternationalAddress IMPLEMENTS Address.I
           INCLUDE Address
           String country
           FUNC String footerHtml()
              RETURN city + "<BR>" + country
           }
        }

        Address.I daffy = NationalAddress.NEW()
        daffy.name = "Daffy Duck"
        daffy.street = "Disneyworld 11"
        daffy.city = "Orlando"
        daffy.zip = "12345"
        IO.write(daffy.toHtml())

        Address.I heidi = InternationalAddress.NEW()
        heidi.name = "Heidi"
        heidi.street = "Bergstrasse 11a"
        heidi.city = "6006 Luzern"
        heidi.country = "Schweiz"
        IO.write(heidi.toHtml())

Alternatives:

Omit the EXTERN declaration.
        + makes it more flexible, because the type doesn't need to be defined.
        + less lines
        - can't give an error where the GROUP is defined, only when it is
          used.

Use an ABSTRACT CLASS.
        - adds a rather complicated concept
        - would need to support subclassing too, creates too many
          possibilities of which some work.


INTERFACE CHANGES

Interfaces are used so that multiple classes can be defined that implement the
behavior defined by the interface.  The classes may change over time, so
long as they implement the interface the behavior doesn't change.

However, sometimes an interface does need to change.  Usually it is an
extension, but it may also be a replacement.  In Zimbu this can be done
gradually by folowing these steps:

        1. Classes define interface Aa, clients use Aa

        2. New interface Bb is defined, which is similar to Aa but adds a
           method and has one method with different arguments.

        3. One by one classes that implement Aa are changed to also implement
           Bb.  Unchanged methods are used for both interfaces.

        4. Clients are changed to switch from using Aa to using Bb.

        5. Interface Aa is deprecated, clients still using Aa can be located
           with a tool.

        6. Once all clients have switched to Bb all code referencing Aa can be
           removed.

What does not work:

        - Changing a method to return a different type.  These are considered
          to be the same function.  Requires using another name.





vim: set tw=78 et sw=2 :
