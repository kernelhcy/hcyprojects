#
# The Zimbu compiler written in Zimbu
#
# Write_C class and module: Methods are invoked from Generate for each node
# to generate C code.
#
# Copyright 2009 Bram Moolenaar
# Licensed under the Apache License, Version 2.0.  See the LICENSE file or
# obtain a copy at: http://www.apache.org/licenses/LICENSE-2.0
#

IMPORT "config.zu"
IMPORT "conversion.zu"
IMPORT "dictstuff.zu"
IMPORT "error.zu"
IMPORT "generate.zu"
IMPORT "lib/libarg.zu"
IMPORT "liststuff.zu"
IMPORT "node.zu"
IMPORT "output.zu"
IMPORT "resolve.zu"
IMPORT "scontext.zu"
IMPORT "scope.zu"
IMPORT "symbol.zu"
IMPORT "zimbufile.zu"

# The methods that are implemented for the Resolve.I interface are commented
# in resolve.zu.
CLASS Write_C IMPLEMENTS Resolve.I

  Resolve.TargetLang targetLang
  string permuName

  NEW()
    targetLang = Resolve.TargetLang.c
  }

  FUNC string thisName(bool insideNew)
    RETURN newThisName
  }

  FUNC string getLangName()
    RETURN "C"
  }

  FUNC ZimbuFile.CodeSpecific getCS(ZimbuFile zimbuFile)
    RETURN zimbuFile.c
  }

  # Return TRUE if there is code at the toplevel (not allowed for imported
  # files).
  FUNC bool toplevelLines(ZimbuFile zimbuFile)
    RETURN !zimbuFile.c.heads.mainLines.empty()
  }

  PROC mainHead(SContext ctx)
      ctx.out.write("int main(int argc, char **argv) {\n")
      LibARG.writeMain(ctx.out)
      ctx.out.write('''  ZglobInit();
return Fmain();
}
int Fmain() {
''')
  }

  PROC mainEnd(Node mainNode, SContext ctx)
    # Only add "return 0;" if there is no RETURN at the end of the node
    # list.
    Node node = mainNode.n_left
    IF node != NIL
      WHILE node.n_next != NIL
        node = node.n_next
      }
    }
    IF node == NIL || node.n_type != Node.Type.return
      ctx.out.write("  return 0;\n")
    }

    ctx.out.write("}\n")
  }

  # >>> C block
  PROC copyC(Node node, SContext ctx)
    ctx.out.write(node.n_string)
  }

  # >>> JS block
  PROC copyJS(Node node, SContext ctx)
  }

  PROC writeAlloc(string typeName, SContext ctx)
    ctx.out.write("Zalloc(sizeof(" .. typeName .. "))")
    ctx.scope.addUsedItem("alloc")
  }

  PROC writeListAlloc(SContext ctx)
    writeAlloc("CListHead", ctx)
  }

  PROC writeNewThis(Symbol sym, SContext ctx)
    ctx.out.writeIndent(1)
    ctx.out.write(sym.className .. " *" .. ctx.scope.thisName .. " = ")
    writeAlloc(sym.className, ctx)
    ctx.out.write(";\n")
  }

  PROC writeNewReturn(Output out)
    out.writeIndent(1)
    out.write("return " .. newThisName .. ";\n")
  }

  PROC writeSymName(Symbol sym, SContext ctx)
    IF sym.type == Node.Type.ref
      ctx.out.write("(*")
      IF sym.returnSymbol != NIL
        ctx.out.write(sym.returnSymbol.cName)
      }
      ctx.out.write(")")
    ELSEIF sym.className != NIL
      ctx.out.write(ctx.scope.thisName .. "->" .. sym.cName)
    ELSE
      ctx.out.write(sym.cName)
    }
  }

  FUNC Symbol id(Node node, SContext ctx, Symbol destSym)
    Symbol sym = node.n_symbol
    IF sym == NIL
      IF ctx.out.writing
        node.error("unknown symbol: " .. node.n_string)
      }
    ELSE
      writeSymName(sym, ctx)
    }
    RETURN node.n_returnSymbol
  }

  FUNC Symbol methodReturnType(Node node, Symbol sym, SContext ctx)
    Symbol retSym
    IF node.n_type == Node.Type.new_def
      retSym = ctx.scope.class
      ctx.out.write(retSym.className .. " *")
    ELSEIF node.n_type == Node.Type.equal_def
      retSym = NEW(Node.Type.bool)
      ctx.out.write("Zbool ")
    ELSEIF node.n_type == Node.Type.func_def
      retSym = Generate.generateDeclType(node.n_returnType, ctx.copyNoOut())
      IF retSym != NIL
        Generate.genType(retSym, node.n_returnType, ctx.out)
      }
    ELSE
      ctx.out.write("void ")
    }

    ctx.out.write(sym.cName .. "(")
    IF ctx.scope.isClassScope() && sym.name != "NEW"
      ctx.out.write(sym.className .. " *" .. ctx.scope.thisName)
      IF node.n_left != NIL
        ctx.out.write(", ")
      }
    }

    RETURN retSym
  }

  PROC writeMethodCall(Symbol func, bool moreArgs, SContext ctx)
    IF func.className != NIL
      ctx.out.write(func.cName .. "(" .. ctx.scope.thisName)
      IF moreArgs
        ctx.out.write(", ")
      }
    ELSE
      ctx.out.write(func.cName .. "(")
    }
  }

  PROC argWithType(bool first, Symbol typeSym, Node typeNode,
                                               string argName, SContext ctx)
    IF !first
      ctx.out.write(", ")
    }
    Generate.genType(typeSym, typeNode, ctx.out)
    ctx.out.write(argName)
  }

  # Return TRUE when forward declarations are to be written.
  FUNC bool doWriteDecl()
    RETURN TRUE
  }

  FUNC Symbol subscript(Node node, SContext ctx, Symbol destSym)
    # Get type of "expr".
    # TODO: this is a hack, it should be possible to use node.n_symbol
    Symbol sym = Generate.genExpr(node.n_left, ctx.copyNoOut(), NIL)

    Symbol ret
    IF sym != NIL
      IF sym.type == Node.Type.list
        ret = ListStuff.generateSubscript(sym, node, FALSE, ctx, destSym)
      ELSEIF sym.type == Node.Type.dict
        ret = DictStuff.generateSubscript(sym, node, FALSE, ctx, destSym)
      ELSEIF sym.type == Node.Type.array
        Generate.genExpr(node.n_left, ctx, Symbol.array)
        ctx.out.write("[")
        Generate.genExpr(node.n_right, ctx, Symbol.int)
        ctx.out.write("]")
        IF sym.returnSymbol != NIL
          ret = sym.returnSymbol.copy()
        ELSEIF ctx.out.writing
          node.error("type of array item unknown")
        }
      ELSEIF sym.type == Node.Type.string
        Generate.genExpr(node.n_left, ctx, Symbol.string)
        ctx.out.write("[")
        Generate.genExpr(node.n_right, ctx, Symbol.int)
        ctx.out.write("]")
        ret = Symbol.int
      ELSEIF ctx.out.writing
        node.error("type does not allow subscript: " .. sym.type.name())
      }
    ELSEIF ctx.out.writing
      # Generate the error message for "expr"
      Generate.genExpr(node.n_left, ctx, NIL)
    }
    RETURN ret
  }

  # Generate accessing an object member |objSym| of an interface |itfSym|.
  PROC iobjectMember(Symbol objSym, Symbol itfSym, Node node,
                                                 SContext ctx, Symbol destSym)
    # some.member -> (*(type *)(some->ptr + table_off[some->type]))
    ctx.out.write("(*(")
    Generate.genType(objSym, node, ctx.out)
    ctx.out.write("*)(")
    Generate.genExpr(node.n_left, ctx, destSym)
    ctx.out.write("->ptr + "
                   .. Generate.classOffTableName(itfSym.class, objSym) .. "[")
    Generate.genExpr(node.n_left, ctx, destSym)
    ctx.out.write("->type]))")
    node.n_undefined = node.n_left.n_undefined
  }

  # Binary operator with int values.
  PROC numberOp(Node node, SContext ctx)
    ctx.out.write("(")
    Generate.genExpr(node.n_left, ctx, Symbol.int)
    string op
    SWITCH node.n_type
      CASE Node.Type.bit_and;   op = " & "
      CASE Node.Type.bit_or;    op = " | "
      CASE Node.Type.bit_xor;   op = " ^ "
      CASE Node.Type.op_rshift; op = " >> "
      CASE Node.Type.op_lshift; op = " << "
      CASE Node.Type.op_mult;   op = " * "
      CASE Node.Type.op_div;    op = " / "
      CASE Node.Type.op_rem;    op = " % "
      CASE Node.Type.op_plus;   op = " + "
      CASE Node.Type.op_minus;  op = " - "
      DEFAULT
              node.error("INTERNAL: numberOp not implemented")
    }
    ctx.out.write(op)
    Generate.genExpr(node.n_right, ctx, Symbol.int)
    ctx.out.write(")")
  }

  # String concatenation operator.
  PROC concatOp(Node node, SContext ctx)
    ctx.scope.addUsedItem("concat")
    ctx.out.write("Zconcat(")
    Generate.genExpr(node.n_left, ctx, Symbol.string)
    ctx.out.write(", ")
    Generate.genExpr(node.n_right, ctx, Symbol.string)
    ctx.out.write(")")
  }

  FUNC Node.Type plusOp(Node node, SContext ctx, Node.Type destType)
    numberOp(node, ctx)
    RETURN Node.Type.int
  }

  PROC incrdecrOp(Node node, SContext ctx)
    IF node.n_type == Node.Type.op_pre_incr
      ctx.out.write("++")
    ELSEIF node.n_type == Node.Type.op_pre_decr
      ctx.out.write("--")
    }
    ctx.out.write("(")
    Generate.genExpr(node.n_left, ctx, Symbol.int)
    ctx.out.write(")")
    IF node.n_type == Node.Type.op_post_incr
      ctx.out.write("++")
    ELSEIF node.n_type == Node.Type.op_post_decr
      ctx.out.write("--")
    }
  }

  PROC booleanOp(Node node, SContext ctx)
    ctx.out.write("(")
    IF node.n_nodeType == Node.Type.nil
      Generate.genExpr(node.n_left, ctx, Symbol.nil)
      IF node.n_type == Node.Type.op_notequal
                                      || node.n_type == Node.Type.op_isnot
        ctx.out.write(" != ")
      ELSE
        ctx.out.write(" == ")
      }
      Generate.genExpr(node.n_right, ctx, Symbol.nil)
    ELSEIF node.n_nodeType == Node.Type.string
      ctx.scope.addUsedItem("strcmp")
      ctx.out.write("Zstrcmp(")
      Generate.genExpr(node.n_left, ctx, Symbol.string)
      ctx.out.write(", ")
      Generate.genExpr(node.n_right, ctx, Symbol.string)
      IF node.n_type == Node.Type.op_equal
        ctx.out.write(") == 0")
      ELSE
        ctx.out.write(") != 0")
      }
    ELSEIF node.n_nodeType == Node.Type.object
      IF node.n_symbol.type == Node.Type.object
        # Create a node for "left.EQUAL(right)"
        Node m = NEW(Node.Type.method)
        m.n_left = NEW(Node.Type.member)
        m.n_left.n_string = "EQUAL"
        m.n_left.n_left = node.n_left
        m.n_left.n_start = node.n_start
        m.n_right = node.n_right
        Generate.generateCall(m, ctx, Symbol.bool, TRUE)
      ELSE
        Generate.genExpr(node.n_left, ctx, node.n_symbol)
        IF node.n_type == Node.Type.op_equal
          ctx.out.write(" == ")
        ELSE
          ctx.out.write(" != ")
        }
        Generate.genExpr(node.n_right, ctx, node.n_symbol)
      }
    ELSE
      bool err = Generate.genExpr(node.n_left, ctx, NIL) == NIL
      err = err || Generate.genExpr(node.n_right, ctx, NIL) == NIL
      IF !err
        node.error("INTERNAL: booleanOp()")
      }
    }
    ctx.out.write(")")
  }

  PROC compareOp(Node node, SContext ctx)
    ctx.out.write("(")
    Generate.genExpr(node.n_left, ctx, Symbol.int)
    SWITCH node.n_type
      CASE Node.Type.op_lt;  ctx.out.write(" < ")
      CASE Node.Type.op_lte; ctx.out.write(" <= ")
      CASE Node.Type.op_gt;  ctx.out.write(" > ")
      CASE Node.Type.op_gte; ctx.out.write(" >= ")
    }
    Generate.genExpr(node.n_right, ctx, Symbol.int)
    ctx.out.write(")")
  }

  PROC andorOp(Node node, SContext ctx)
    ctx.out.write("(")
    Generate.genExpr(node.n_left, ctx, Symbol.bool)
    IF node.n_type == Node.Type.op_and
      ctx.out.write(" && ")
    ELSE
      ctx.out.write(" || ")
    }
    Generate.genExpr(node.n_right, ctx, Symbol.bool)
    ctx.out.write(")")
  }

  FUNC Symbol parens(Node node, SContext ctx, Symbol destSym)
    ctx.out.write("(")
    Symbol ret = Generate.genExpr(node.n_left, ctx, destSym)
    ctx.out.write(")")
    RETURN ret
  }

  FUNC Symbol altOp(Node node, SContext ctx, Symbol destSym)
    ctx.out.write("(")
    Generate.genExpr(node.n_cond, ctx, Symbol.bool)
    ctx.out.write(") ? (")
    Generate.genExpr(node.n_left, ctx, destSym)
    ctx.out.write(") : (")
    Symbol symr = Generate.genExpr(node.n_right, ctx, destSym)
    ctx.out.write(")")
    # TODO: if destSym is NIL check syml and symr are the same type
    IF symr != NIL
      RETURN symr.copy()
    }
    RETURN NIL
  }

  FUNC Symbol listPart(Node node, SContext ctx, Symbol destSym)
    RETURN ListStuff.generateListPart_C(node, ctx, destSym)
  }

  PROC dictPart(Node node, Symbol ret, SContext ctx)
    DictStuff.generateDictPart_C(node, ret, ctx)
  }

  FUNC Symbol expr(Node node, SContext ctx, Symbol destSym)
    Symbol retConverted
    string close = ""

    # A node may be visited more than once, check that the destination type
    # is specified.
    IF destSym != NIL && destSym.type != Node.Type.unknown
      SWITCH node.n_conversion
        CASE Conversion.int2string
          ctx.scope.addUsedItem("int2string")
          ctx.out.write("Zint2string(")
          close = ")"
          retConverted = NEW(Node.Type.string)
        CASE Conversion.bool2string
          ctx.scope.addUsedItem("bool2string")
          ctx.out.write("Zbool2string(")
          close = ")"
          retConverted = NEW(Node.Type.string)
        CASE Conversion.status2string
          ctx.scope.addUsedItem("status2string")
          ctx.out.write("Zstatus2string(")
          close = ")"
          retConverted = NEW(Node.Type.string)
        CASE Conversion.object2iobject
          ctx.scope.addUsedItem("allocZoref")
          ctx.out.write("ZallocZoref(")
          int idx = destSym.class.childIndex(node.n_ret_class)
          IF idx < 0
            node.error("Class type mismatch")
          }
          close = ", " .. idx .. ")"
          retConverted = destSym
      }
    }

    Symbol ret = Generate.genExprChecked(node, ctx, destSym)

    ctx.out.write(close)
    IF retConverted != NIL
      RETURN retConverted
    }
    RETURN ret
  }

  # Write the files for an imported file.
  FUNC string writeImport(ZimbuFile import, Output.Group dummyOuts, Scope scope)
    IO.mkdir(import.outDir)
    string root = import.outDir .. "/" .. import.rootName
    # TODO: include directory name, replace "/" with "__"
    string defRoot = "INC_" .. import.rootName

    IF !import.c.heads.inits.empty()
      # Add function for inits to bodies
      import.c.heads.declares.add("void " .. import.initFunc .. "();\n")
      import.c.heads.funcBodies.add("void " .. import.initFunc .. "() {\n")
      import.c.heads.funcBodies.add(" static int done = 0;\n")
      import.c.heads.funcBodies.add(" if (!done) {\n")
      import.c.heads.funcBodies.add("  done = 1;\n")
      import.c.heads.funcBodies.append(import.c.heads.inits)
      import.c.heads.funcBodies.add(" }\n")
      import.c.heads.funcBodies.add("}\n")
    }

    writeImportFile(root .. ".t.h", import.c.heads.typedefs,
                                               "TYPEDEFS", defRoot .. "_T")
    writeImportFile(root .. ".s.h", import.c.heads.structs,
                                                "STRUCTS", defRoot .. "_S")
    writeImportFile(root .. ".d.h", import.c.heads.declares,
                          "DECLARE FUNCTIONS AND GLOBALS", defRoot .. "_D")
    writeImportFile(root .. ".b.c", import.c.heads.funcBodies,
                                        "FUNCTION BODIES", defRoot .. "_B")
    RETURN root .. ".b.c"
  }

  # Write one of the files of an imported module.
  PROC writeImportFile(string fname, Output.FragmentHead head,
                                                  string header, string def)
    IO.File fd = IO.fileWriter(fname)
    IF fd == NIL
      IO.writeLine("ERROR: Cannot open file for writing: " .. fname)
      EXIT 1
    }
    fd.write("#define " .. def .. " 1\n")
    fd.write("/*\n * " .. header .. "\n */\n")
    head.write(fd)
    fd.close()
  }

  # Write lines to "myOuts" to include the header files for an
  # imported file.
  PROC writeIncludeImport(ZimbuFile import, Output.Group myOuts, Scope scope)
    # Include the generated files in the current file.
    string pre = "#ifndef INC_" .. import.rootName
    string inc = "#include \""
    # TODO: do this properly
    IF scope.importIndent != ""
      inc ..= "../"
    }
    string dir = scope.dirName
    WHILE dir != NIL && dir != ""
      inc ..= "../"
      int slash = dir.index('/')
      IF slash < 0
        BREAK
      }
      dir = dir.byteSlice(slash + 1, -1)
    }
    inc ..= import.outDir .. "/"
    inc ..= import.rootName

    myOuts.typeOut.write(pre .. "_T\n")
    myOuts.typeOut.write(inc .. ".t.h\"\n#endif\n")
    myOuts.structOut.write(pre .. "_S\n")
    myOuts.structOut.write(inc .. ".s.h\"\n#endif\n")
    myOuts.declOut.write(pre .. "_D\n")
    myOuts.declOut.write(inc .. ".d.h\"\n#endif\n")
    myOuts.bodyOut.write(pre .. "_B\n")
    myOuts.bodyOut.write(inc .. ".b.c\"\n#endif\n")
    IF !import.c.heads.inits.empty()
      myOuts.initOut.write("  " .. import.initFunc .. "();\n")
    }
  }

  FUNC bool needWrite(ZimbuFile zimbuFile)
    IF zimbuFile.c.startedWrite != NIL
      RETURN FALSE
    }
    zimbuFile.c.startedWrite = "yes"
    RETURN TRUE
  }

  PROC writeClassDef(string name, Output typeOut)
    typeOut.write("typedef struct " .. name .. "__S " .. name .. ";\n")
  }

  # Write class declaration. |structOut| has the body.
  PROC writeClassDecl(Symbol classSym, Output.Group outs, Output structOut)
    string name = classSym.cName
    outs.structOut.write("struct " .. name .. "__S {\n")
    outs.structOut.append(structOut)
    outs.structOut.write("};\n")
  }

  # Write the default init value for |sym|.
  PROC defaultInit(Symbol sym, Output out)
    SWITCH sym.type
      CASE Node.Type.class
      CASE Node.Type.i_object
      CASE Node.Type.string
      CASE Node.Type.list
      CASE Node.Type.dict
        out.write("NULL")
      DEFAULT
        out.write("0")
    }
  }

  PROC nil(SContext ctx)
    ctx.out.write("NULL")
  }

  PROC member(string name, Output out)
    out.write("->" .. name)
  }

  PROC vardecl(SContext ctx, Output out)
  }

  # Write the type of a variable or return value.
  PROC vartype(Symbol sym, Node node, Scope scope, Output out)
    SWITCH sym.type
      CASE Node.Type.class
      CASE Node.Type.object
          IF sym.attributes.abstract
            node.error("Cannot use abstract class " .. sym.name)
          }
          out.write(sym.className .. " *")
          RETURN
      CASE Node.Type.i_object
          out.write("Zoref *")
          RETURN
      CASE Node.Type.list
          out.write("CListHead *")
          RETURN
      CASE Node.Type.dict
          out.write("CDictHead *")
          RETURN
      CASE Node.Type.proc_ref
          out.write("void *")
          RETURN
      CASE Node.Type.func_ref
          out.write("void *")
          RETURN
      CASE Node.Type.string
          out.write("char *")
          RETURN
      CASE Node.Type.ref
          vartype(sym.returnSymbol, node, scope, out)
          out.write(" *")
          RETURN
      CASE Node.Type.bool
          out.write("Zbool ")
          RETURN
      CASE Node.Type.status
          out.write("Zstatus ")
          RETURN
      CASE Node.Type.bits_small
          out.write("Zbits ")
          RETURN
      CASE Node.Type.bits_big
          out.write("Zbbits ")
          RETURN
      CASE Node.Type.enum
          out.write("Zenum ")
          RETURN
      CASE Node.Type.int
          out.write("Zint ")
          RETURN
      DEFAULT
          IF out.writing
            node.error("Declaration of unknown type " .. sym.type.name())
          }
    }
  }

  PROC forStart(Output out)
    out.write("Zfor_T *Zf = ZforNew(")
  }

  PROC forLoop(Symbol varSym, Output out)
    string typeName = varSym.isPointerType() ? "Ptr" : "Int"
    string cast = varSym.isPointerType() ? "(char **)" : ""
    out.write("for (ZforGet" .. typeName .. "(Zf, " .. cast
                                              .. "&" .. varSym.cName .. "); ")
    out.write("ZforCont(Zf); ")
    out.write("ZforNext" .. typeName .. "(Zf, " .. cast ..
                                            "&" .. varSym.cName .. ")) {\n")
  }

  SHARED
    string newThisName = "THIS"

    list<proc<Scope, IO.File>> includeWriters = NEW()
    list<proc<Scope, IO.File>> typedefWriters = NEW()
    list<proc<Scope, IO.File>> declWriters = NEW()
    list<proc<Scope, IO.File>> bodyWriters = NEW()

    # Write C code from |heads| into outFile.
    PROC writeFile(Output.Heads heads, Scope topScope, IO.File outFile)
      heads.declares.add("void ZglobInit();\n")
      heads.inits.insert("void ZglobInit() {\n")
      heads.inits.add("}\n\n")

      writeIncludes(topScope, outFile)

      outFile.write("/*\n * TYPEDEFS\n */\n")
      writeTypedefs(topScope, outFile)
      heads.typedefs.write(outFile)

      outFile.write("/*\n * STRUCTS\n */\n")
      writeDecl(topScope, outFile)
      heads.structs.write(outFile)

      outFile.write("/*\n * DECLARE FUNCTIONS AND GLOBALS\n */\n")
      writeBodies(topScope, outFile)
      heads.declares.write(outFile)

      outFile.write("/*\n * FUNCTION BODIES\n */\n")
      heads.funcBodies.write(outFile)

      outFile.write("/*\n * INIT GLOBALS\n */\n")
      heads.inits.write(outFile)

      outFile.write("/*\n * MAIN\n */\n")
      heads.mainLines.write(outFile)
    }

    # Write the required "#include" lines to |fd|.
    PROC writeIncludes(Scope topScope, IO.File fd)
      IF topScope.usedItems.has("strcmp")
          || topScope.usedItems.has("concat")
          || topScope.usedItems.has("stringSlice")
          || topScope.usedItems.has("stringByteSlice")
          || topScope.usedItems.has("garray")
          || topScope.usedItems.has("stringToLower")
          || topScope.usedItems.has("stringToUpper")
          || topScope.usedItems.has("stringFind")
          || topScope.usedItems.has("stringStartsWith")
          || topScope.usedItems.has("stringEndsWith")
        fd.write("#include <string.h>\n")
      }
      # always needed for malloc() and calloc()
      fd.write("#include <stdlib.h>\n")
      IF topScope.usedItems.has("unistd.h")
        fd.write("#include <unistd.h>\n")
      }
      IF topScope.usedItems.has("sys/types.h")
        fd.write("#include <sys/types.h>\n")
      }
      IF topScope.usedItems.has("fcntl.h")
        fd.write("#include <fcntl.h>\n")
      }
      IF topScope.usedItems.has("sys/stat.h")
        fd.write("#include <sys/stat.h>\n")
      }
      IF topScope.usedItems.has("stringToLower")
          || topScope.usedItems.has("stringToUpper")
        fd.write("#include <ctype.h>\n")
      }
      fd.write("#include <stdio.h>\n")  # always needed for NULL
      IF topScope.usedItems.has("strings.h")
        fd.write("#include <strings.h>\n")
      }
      IF topScope.usedItems.has("time.h")
        fd.write("#include <time.h>\n")
      }
      fd.write("\n")

      # Write includes for libraries.
      FOR p IN includeWriters
        p(topScope, fd)
      }
    }

    # Write all needed typedefs to |fd|.
    PROC writeTypedefs(Scope topScope, IO.File fd)
      # MingW doesn't handle "long long" properly.
      # TODO: auto configuration
      fd.write("#ifdef __MINGW32__\n")
      fd.write("typedef long Zint;\n")
      fd.write("typedef long Zbbits;\n")
      fd.write("#else\n")
      fd.write("typedef " .. Config.int64name .. " Zint;\n")
      fd.write("typedef " .. Config.int64name .. " Zbbits;\n")
      fd.write("#endif\n")
      fd.write("typedef int Zbits;\n")
      fd.write("typedef int Zbool;\n")
      fd.write("typedef int Zstatus;\n")
      fd.write("typedef int Zenum;\n")
      fd.write("typedef struct Zoref__S Zoref;\n")

      IF topScope.usedItems.has("garray")
        fd.write("typedef struct garray__S garray_T;\n")
      }

      IF topScope.usedItems.has("for")
        fd.write("typedef struct Zfor__S Zfor_T;\n")
      }

      # List type
      ListStuff.writeTypedefs_C(topScope, fd)

      # Dict type
      DictStuff.writeTypedefs(topScope, fd)

      # Write typedefs for libraries.
      FOR p IN typedefWriters
        p(topScope, fd)
      }

      fd.write("\n")
    }

    # Write struct and function declarations to |fd|.
    # Some function bodies that don't require other types are defined as well.
    PROC writeDecl(Scope topScope, IO.File fd)
      # Efficient way to define EOF
      fd.write("#define MIO__Veof EOF\n")
      fd.write("\n")

      # For interface lookup tables.
      IF topScope.usedItems.has("dummy")
        fd.write("struct {} dummy;\n")
        fd.write("\n")
      }

      IF topScope.usedItems.has("list")
          || DictStuff.useDict
          || topScope.usedItems.has("alloc")
          || topScope.usedItems.has("for")
        fd.write('''
void *Zalloc(size_t size) {
  return calloc(1, size);
}
''')
      }

      IF topScope.usedItems.has("list") || DictStuff.useDict
        fd.write('''
void Zerror(char *msg) {
  fprintf(stderr, "ERROR: %s\n", msg);
}
''')
      }

      # An object reference of an interface type.
      fd.write('''
struct Zoref__S {
  char *ptr;
  int  type;
};
''')

      IF topScope.usedItems.has("garray")
        fd.write('''
struct garray__S {
  char *data;
  int  used;
  int  len;
};
''')
      }

      IF topScope.usedItems.has("for")
        fd.write('''
struct Zfor__S {
  int type;
  CListItem *listItem;
};
''')
      }

      # List type
      ListStuff.writeDecl_C(topScope, fd)

      # Dict type
      DictStuff.writeDecl(topScope, fd)

      # Write structs for libraries.
      FOR p IN declWriters
        p(topScope, fd)
      }
    }

    PROC writeBodies(Scope topScope, IO.File fd)
      IF topScope.usedItems.has("allocZoref")
        # TODO: garbage collection.
        fd.write('''
Zoref *ZallocZoref(void *ptr, Zint type) {
  Zoref *p = Zalloc(sizeof(Zoref));
  p->ptr = ptr;
  p->type = type;
  return p;
}
''')
      }

      IF topScope.usedItems.has("garray")
        fd.write('''
ga_append(garray_T *ga, char *str) {
  int len = strlen(str);
  if (ga->data == NULL || ga->used + len >= ga->len) {
    int newLen = ga->used + len + 200;
    char *newData = malloc(newLen);
    if (ga->data != NULL) {
      memmove(newData, ga->data, ga->used);
      free(ga->data);
    }
    ga->data = newData;
    ga->len = newLen;
  }
  strcpy(ga->data + ga->used, str);
  ga->used += len;
}
''')
      }

      IF topScope.usedItems.has("strcmp")
        fd.write('''
int Zstrcmp(char *s1, char *s2) {
  if (s1 == NULL || s2 == NULL) {
    if (s1 == NULL && s2 == NULL)
      return 0;
    if (s1 == NULL)
      return -1;
    return 1;
  }
  return strcmp(s1, s2);
}
''')
      }

      IF topScope.usedItems.has("concat")
        fd.write('''
char *Zconcat(char *s1, char *s2) {
  char *ss1 = s1 == NULL ? "NULL" : s1;
  char *ss2 = s2 == NULL ? "NULL" : s2;
  char *p = malloc(strlen(ss1) + strlen(ss2) + 1);
  strcpy(p, ss1);
  strcat(p, ss2);
  return p;
}
''')
      }
      IF topScope.usedItems.has("bool2string")
        fd.write('''
char *Zbool2string(Zbool n) {
  return n == 0 ? "FALSE" : "TRUE";
}
''')
      }
      IF topScope.usedItems.has("status2string")
        fd.write('''
char *Zstatus2string(Zstatus n) {
  return n == 0 ? "FAIL" : "OK";
}
''')
      }
      IF topScope.usedItems.has("int2string")
        # TODO: %lld depends on type of Zint
        fd.write('''
char *Zint2string(Zint n) {
  char *p = malloc(30);
  sprintf(p, "%lld", n);
  return p;
}
''')
      }
      IF topScope.usedItems.has("fixSign")
        # Used for converting intN to int.  "mask" has all bits set, except the
        # lower ones that contain a positive value.  For int5 it is ~15.
        # When the topmost valid bit in "n" is set the value is negative and
        # needs to have all "mask" bits set.
        # TODO: support for 32 and 64 bit separately for efficiency
        fd.write('''
Zint ZFixSign(Zint n, Zint mask) {
  if (n & mask)
    return n | mask;
  return n;
}
''')
      }
      IF topScope.usedItems.has("tochar")
        fd.write('''
char *Ztochar(Zint n) {
  char *p = malloc(2);
  p[0] = n; p[1] = 0;
  return p;
}
''')
      }
      IF topScope.usedItems.has("enum2string")
        fd.write("\nchar *Zenum2string(char **names, size_t nm, Zenum n) {\n")
        fd.write("  return (n < 0 || n >= nm) ? \"INVALID\" : names[n];\n")
        fd.write("}\n")
      }
      IF topScope.usedItems.has("stringSlice")
        # TODO: make this work for UTF-8.
        fd.write('''
char *ZStringSlice(char *s, Zint start, Zint end) {
  char *ss = (s == NULL) ? "NULL" : s;
  char *r;
  Zint l = (Zint)strlen(ss);
  Zint is = start < 0 ? l + start : start;
  Zint ie = end < 0 ? l + end : end;
  if (is < 0) is = 0;
  if (is > l) is = l;
  if (ie < is - 1) ie = is - 1;
  if (ie >= l) ie = l - 1;
  l = ie - is + 1;
  r = malloc(l + 1);
  strncpy(r, ss + is, l);
  r[l] = 0;
  return r;
}
''')
      }
      IF topScope.usedItems.has("stringByteSlice")
        fd.write('''
char *ZStringByteSlice(char *s, Zint start, Zint end) {
  char *ss = (s == NULL) ? "NULL" : s;
  char *r;
  Zint l = (Zint)strlen(ss);
  Zint is = start < 0 ? l + start : start;
  Zint ie = end < 0 ? l + end : end;
  if (is < 0) is = 0;
  if (is > l) is = l;
  if (ie < is - 1) ie = is - 1;
  if (ie >= l) ie = l - 1;
  l = ie - is + 1;
  r = malloc(l + 1);
  strncpy(r, ss + is, l);
  r[l] = 0;
  return r;
}
''')
      }
      IF topScope.usedItems.has("stringToInt")
        # TODO: throw exception if illegal char found.
        fd.write('''
Zint ZStringToInt(char *s) {
  Zint r;
  if (s == NULL) return 0;
  sscanf(s, "%lld", &r);
  return r;
}
''')
      }
      IF topScope.usedItems.has("stringToLower")
        # TODO: Make it work for UTF-8
        fd.write('''
char *ZStringToLower(char *ss) {
  char *r;
  char *s;
  char *d;
  if (ss == NULL)
    return NULL;
  r = (char *)Zalloc(strlen(ss) + 1);
  s = ss;
  d = r;
  while (*s != 0)
    *d++ = tolower(*s++);
  *d = 0;
  return r;
}
''')
      }
      IF topScope.usedItems.has("stringToUpper")
        # TODO: Make it work for UTF-8
        fd.write('''
char *ZStringToUpper(char *ss) {
  char *r;
  char *s;
  char *d;
  if (ss == NULL)
    return NULL;
  r = (char *)Zalloc(strlen(ss) + 1);
  s = ss;
  d = r;
  while (*s != 0)
    *d++ = toupper(*s++);
  *d = 0;
  return r;
}
''')
      }
      IF topScope.usedItems.has("stringFind")
        fd.write('''
Zint ZStringFind(char *big, char *small) {
  char *r;
  if (big == NULL || small == NULL)
    return -1;
  r = strstr(big, small);
  if (r == NULL)
    return -1;
  return r - big;
}
''')
      }
      IF topScope.usedItems.has("stringStartsWith")
        fd.write('''
Zbool ZStringStartsWith(char *big, char *small) {
  int i;
  if (big == NULL || small == NULL)
    return 0;
  for (i = 0; small[i] != 0; ++i) {
    if (big[i] != small[i])
      return 0;
  }
  return 1;
}
''')
      }
      IF topScope.usedItems.has("stringEndsWith")
        fd.write('''
Zbool ZStringEndsWith(char *big, char *small) {
  int i, j;
  if (big == NULL || small == NULL)
    return 0;
  i = strlen(big) - 1;
  j = strlen(small) - 1;
  while (1) {
    if (j < 0)
      return 1;
    if (i < 0)
      return 0;
    if (big[i] != small[j])
      return 0;
    --i;
    --j;
  }
}
''')
      }
      IF topScope.usedItems.has("stringBinToInt")
        # TODO: throw exception if illegal char found.
        fd.write('''
Zint ZStringBinToInt(char *s) {
  Zint r = 0;
  if (s != NULL) {
    char *p;
    for (p = s; *p != 0; ++p) {
      if (*p == '0')
        r <<= 1;
      else if (*p == '1')
        r = (r << 1) + 1;
      else
        break;
    }
  }
  return r;
}
''')
      }
      IF topScope.usedItems.has("stringHexToInt")
        # TODO: %llx should come from Config.
        # TODO: throw exception if illegal char found.
        # TODO: should argument to sscanf() be unsigned?
        fd.write('''
Zint ZStringHexToInt(char *s) {
  Zint r;
  if (s == NULL) return 0;
  sscanf(s, "%llx", &r);
  return r;
}
''')
      }
      IF topScope.usedItems.has("stringQuotedToInt")
        # TODO: throw exception if illegal char found.
        fd.write('''
Zint ZStringQuotedToInt(char *s) {
  Zint r = 0;
  if (s != NULL) {
    char *p;
    for (p = s; *p != 0; ++p) {
      if (*p >= '0' && *p <= '9')
        r = r * 10 + (*p - '0');
      else if (*p != '\'')
        break;
    }
  }
  return r;
}
''')
      }
      IF topScope.usedItems.has("stringQuotedBinToInt")
        # TODO: throw exception if illegal char found.
        fd.write('''
Zint ZStringQuotedBinToInt(char *s) {
  Zint r = 0;
  if (s != NULL) {
    char *p;
    for (p = s; *p != 0; ++p) {
      if (*p == '0')
        r <<= 1;
      else if (*p == '1')
        r = (r << 1) + 1;
      else if (*p != '\'')
        break;
    }
  }
  return r;
}
''')
      }
      IF topScope.usedItems.has("stringQuotedHexToInt")
        # TODO: throw exception if illegal char found.
        fd.write('''
Zint ZStringQuotedHexToInt(char *s) {
  Zint r = 0;
  if (s != NULL) {
    char *p;
    for (p = s; *p != 0; ++p) {
      if (*p >= '0' && *p <= '9')
        r = r * 16 + (*p - '0');
      else if (*p >= 'a' && *p <= 'f')
        r = r * 16 + (*p - 'a' + 10);
      else if (*p >= 'A' && *p <= 'F')
        r = r * 16 + (*p - 'A' + 10);
      else if (*p != '\'')
        break;
    }
  }
  return r;
}
''')
      }
      IF topScope.usedItems.has("stringIndex")
        # TODO: handle utf-8 characters
        fd.write('''
Zint ZStringIndex(char *s, Zint c) {
  unsigned char *p;
  if (s == NULL) return -1;
  for (p = (unsigned char *)s; *p != 0; ++p) {
    if (*p == c) return (Zint)((char *)p - s);
  }
  return -1;
}
''')
      }
      IF topScope.usedItems.has("stringRindex")
        # TODO: handle utf-8 characters
        fd.write('''
Zint ZStringRindex(char *s, Zint c) {
  unsigned char *p;
  unsigned char *found;
  if (s == NULL) return -1;
  found = NULL;
  for (p = (unsigned char *)s; *p != 0; ++p) {
    if (*p == c) found = p;
  }
  if (found == NULL) return -1;
  return (int)((char *)found - s);
}
''')
      }

      # List type
      ListStuff.writeBody_C(topScope, fd)

      # Dict type
      DictStuff.writeBody(topScope, fd)

      # FOR x in xlist
      IF topScope.usedItems.has("for")
        fd.write('''
Zfor_T *ZforNew(void *p, int type) {
  Zfor_T *s = Zalloc(sizeof(Zfor_T));
  s->type = type;
  if (type == 2)
    s->listItem = ((CListHead *)p)->first;
  return s;
}
void ZforGetPtr(Zfor_T *s, char **p) {
  if (s->type == 2 && s->listItem != NULL)
    *p = s->listItem->Pval;
  else
    *p = NULL;
}
void ZforGetInt(Zfor_T *s, Zint *p) {
  if (s->type == 2 && s->listItem != NULL)
    *p = s->listItem->Ival;
  else
    *p = 0;
}
int ZforCont(Zfor_T *s) {
  if (s->type == 2)
    return s->listItem != NULL;
  return 0;
}
void ZforNextPtr(Zfor_T *s, char **p) {
  if (s->type == 2 && s->listItem != NULL)
    s->listItem = s->listItem->next;
  ZforGetPtr(s, p);
}
void ZforNextInt(Zfor_T *s, Zint *p) {
  if (s->type == 2 && s->listItem != NULL)
    s->listItem = s->listItem->next;
  ZforGetInt(s, p);
}
''')
      }

      # Write bodies for libraries.
      FOR p IN bodyWriters
        p(topScope, fd)
      }
    }


  } # SHARED

}
